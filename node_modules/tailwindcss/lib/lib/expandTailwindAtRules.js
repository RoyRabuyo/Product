"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return expandTailwindAtRules;
    }
});
const _fs = /*#__PURE__*/ _interop_require_default(require("fs"));
const _quicklru = /*#__PURE__*/ _interop_require_default(require("@alloc/quick-lru"));
const _sharedState = /*#__PURE__*/ _interop_require_wildcard(require("./sharedState"));
const _generateRules = require("./generateRules");
const _log = /*#__PURE__*/ _interop_require_default(require("../util/log"));
const _cloneNodes = /*#__PURE__*/ _interop_require_default(require("../util/cloneNodes"));
const _defaultExtractor = require("./defaultExtractor");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
let env = _sharedState.env;
const builtInExtractors = {
    DEFAULT: _defaultExtractor.defaultExtractor
};
const builtInTransformers = {
    DEFAULT: (content)=>content,
    svelte: (content)=>content.replace(/(?:^|\s)class:/g, " ")
};
function getExtractor(context, fileExtension) {
    let extractors = context.tailwindConfig.content.extract;
    return extractors[fileExtension] || extractors.DEFAULT || builtInExtractors[fileExtension] || builtInExtractors.DEFAULT(context);
}
function getTransformer(tailwindConfig, fileExtension) {
    let transformers = tailwindConfig.content.transform;
    return transformers[fileExtension] || transformers.DEFAULT || builtInTransformers[fileExtension] || builtInTransformers.DEFAULT;
}
let extractorCache = new WeakMap();
// Scans template contents for possible classes. This is a hot path on initial build but
// not too important for subsequent builds. The faster the better though â€” if we can speed
// up these regexes by 50% that could cut initial build time by like 20%.
function getClassCandidates(content, extractor, candidates, seen) {
    if (!extractorCache.has(extractor)) {
        extractorCache.set(extractor, new _quicklru.default({
            maxSize: 25000
        }));
    }
    for (let line of content.split("\n")){
        line = line.trim();
        if (seen.has(line)) {
            continue;
        }
        seen.add(line);
        if (extractorCache.get(extractor).has(line)) {
            for (let match of extractorCache.get(extractor).get(line)){
                candidates.add(match);
            }
        } else {
            let extractorMatches = extractor(line).filter((s)=>s !== "!*");
            let lineMatchesSet = new Set(extractorMatches);
            for (let match of lineMatchesSet){
                candidates.add(match);
            }
            extractorCache.get(extractor).set(line, lineMatchesSet);
        }
    }
}
/**
 *
 * @param {[import('./offsets.js').RuleOffset, import('postcss').Node][]} rules
 * @param {*} context
 */ function buildStylesheet(rules, context) {
    let sortedRules = context.offsets.sort(rules);
    let returnValue = {
        base: new Set(),
        defaults: new Set(),
        components: new Set(),
        utilities: new Set(),
        variants: new Set()
    };
    for (let [sort, rule] of sortedRules){
        returnValue[sort.layer].add(rule);
    }
    return returnValue;
}
function expandTailwindAtRules(context) {
    return async (root)=>{
        let layerNodes = {
            base: null,
            components: null,
            utilities: null,
            variants: null
        };
        root.walkAtRules((rule)=>{
            // Make sure this file contains Tailwind directives. If not, we can save
            // a lot of work and bail early. Also we don't have to register our touch
            // file as a dependency since the output of this CSS does not depend on
            // the source of any templates. Think Vue <style> blocks for example.
            if (rule.name === "tailwind") {
                if (Object.keys(layerNodes).includes(rule.params)) {
                    layerNodes[rule.params] = rule;
                }
            }
        });
        if (Object.values(layerNodes).every((n)=>n === null)) {
            return root;
        }
        var _context_candidates;
        // ---
        // Find potential rules in changed files
        let candidates = new Set([
            ...(_context_candidates = context.candidates) !== null && _context_candidates !== void 0 ? _context_candidates : [],
            _sharedState.NOT_ON_DEMAND
        ]);
        let seen = new Set();
        env.DEBUG && console.time("Reading changed files");
        /** @type {[item: {file?: string, content?: string}, meta: {transformer: any, extractor: any}][]} */ let regexParserContent = [];
        for (let item of context.changedContent){
            let transformer = getTransformer(context.tailwindConfig, item.extension);
            let extractor = getExtractor(context, item.extension);
            regexParserContent.push([
                item,
                {
                    transformer,
                    extractor
                }
            ]);
        }
        const BATCH_SIZE = 500;
        for(let i = 0; i < regexParserContent.length; i += BATCH_SIZE){
            let batch = regexParserContent.slice(i, i + BATCH_SIZE);
            await Promise.all(batch.map(async ([{ file , content  }, { transformer , extractor  }])=>{
                content = file ? await _fs.default.promises.readFile(file, "utf8") : content;
                getClassCandidates(transformer(content), extractor, candidates, seen);
            }));
        }
        env.DEBUG && console.timeEnd("Reading changed files");
        // ---
        // Generate the actual CSS
        let classCacheCount = context.classCache.size;
        env.DEBUG && console.time("Generate rules");
        env.DEBUG && console.time("Sorting candidates");
        let sortedCandidates = new Set([
            ...candidates
        ].sort((a, z)=>{
            if (a === z) return 0;
            if (a < z) return -1;
            return 1;
        }));
        env.DEBUG && console.timeEnd("Sorting candidates");
        (0, _generateRules.generateRules)(sortedCandidates, context);
        env.DEBUG && console.timeEnd("Generate rules");
        // We only ever add to the classCache, so if it didn't grow, there is nothing new.
        env.DEBUG && console.time("Build stylesheet");
        if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {
            context.stylesheetCache = buildStylesheet([
                ...context.ruleCache
            ], context);
        }
        env.DEBUG && console.timeEnd("Build stylesheet");
        let { defaults: defaultNodes , base: baseNodes , components: componentNodes , utilities: utilityNodes , variants: screenNodes  } = context.stylesheetCache;
        // ---
INDX( 	 åA          (   ˆ  è       o       Ú~ Ú        sÝ    p Z     íØ    ª¡£«Úºð[Å¡ƒÕª¡£«Úª¡£«Ú       ß              S Q 7 2 9 D ~ 1 . P N G 0 l o  Ý    p Z     íØ    I?¨£«Ú‚¡lÅ¡ƒÕI?¨£«ÚI?¨£«Ú                    S Q 7 6 6 8 ~ 1 . P N G 0 l o ˆÝ    p Z     íØ    Ý¥£«Ú…µ`Å¡ƒÕÝ¥£«ÚÝ¥£«Ú       ¼              S Q 7 8 7 B ~ 1 . P N G 0 l o ¸Ý    p Z     íØ    ´­£«ÚMfqÅ¡ƒÕ´­£«Ú´­£«Ú       A              S Q 7 C 6 C ~ 1 . P N G 0 l  ¶Ý    p Z     íØ    ´­£«ÚMfqÅ¡ƒÕ´­£«Ú´­£«Ú       Ê              S Q 7 E F 2 ~ 1 . P N G 0 l o wÝ    p Z     íØ    ª¡£«ÚS^Å¡ƒÕª¡£«Úª¡£«Ú                     S Q 8 3 B 3 ~ 1 . P N G 0 l o |Ý    p Z     íØ    ×z££«ÚS^Å¡ƒÕ×z££«Ú×z££«Ú                      S Q 8 C 8 7 ~ 1 . P N G 0 l o €Ý    p Z     íØ    ×z££«Ú…µ`Å¡ƒÕ×z££«Ú×z££«Ú       ¯
              S Q 8 D 1 F ~ 1 . P N G 0 l o ¾Ý    p Z     íØ    ëe¯£«Ú³ÈsÅ¡ƒÕëe¯£«Úëe¯£«Ú      ´              S Q 8 F A 2 ~ 1 . P N G 0 l o ´Ý    p Z     íØ    ´­£«ÚMfqÅ¡ƒÕ´­£«Ú´­£«Ú       L              S Q 9 1 1 1 ~ 1 . P N G 0 l o ¬Ý    p Z     íØ    z¡ª£«Ú‚¡lÅ¡ƒÕz¡ª£«Úz¡ª£«Ú       …              S Q 9 1 2 D ~ 1 . P N G 0 l o {Ý    p Z     íØ    ×z££«ÚS^Å¡ƒÕ×z££«Ú×z££«Ú       ¹              S Q 9 7 1 9 ~ 1 . P N G 0 l o ¯Ý    p Z     íØ    ´­£«ÚçoÅ¡ƒÕ´­£«Ú´­£«ÚÈ      Ã              S Q 9 8 8 8 ~ 1 . P N G 0 l o ¡Ý    p Z    íØ    z¡ª£«Ú?jÅ¡ƒÕz¡ª£«Úz¡ª£«Ú       J              S Q 9 9 7 6 ~ 1 . P N G 0 l o ¢Ý    p Z     íØ    z¡ª£«ÚçoÅ¡ƒÕz¡ª£«Úz¡ª£«Ú       µ              S Q 9 B 0 D ~ 1 . P N G 0 l o ½Ý    p Z     íØ    ëe¯£«Ú³ÈsÅ¡ƒÕëe¯£«Úëe¯£«Ú       a              S Q A 2 C 0 ~ 1 . P N G 0 l o ’Ý    p Z     íØ    Ý¥£«ÚQzeÅ¡ƒÕI?¨£«ÚI?¨£«Ú       ú              S Q A 9 9 0 ~ 1 . P N G 0 l o ªÝ    p Z     íØ    z¡ª£«Ú‚¡lÅ¡ƒÕz¡ª£«Úz¡ª£«Ú       û              S Q A A 2 F ~ 1 . P N G 0 l o “Ý    p Z     íØ    I?¨£«ÚQzeÅ¡ƒÕI?¨£«ÚI?¨£«Ú       ú              S Q A B 2 7 ~ 1 . P N G 0 l o               íØ    I?¨£«Ú?jÅ¡ƒÕI?¨£«ÚI?¨£«Ú       b              S Q B E 8 B ~ 1 . P N G 0 l o Ý    p Z     íØ    Ý¥£«Ú¶ÜgÅ¡ƒÕÝ¥£«ÚÝ¥£«Ú       é              S Q C C 4 D ~ 1 . P N G 0 l o »Ý    p Z     íØ    ëe¯£«Ú³ÈsÅ¡ƒÕëe¯£«Úëe¯£«Ú       I              S Q C C A 6 ~ 1 . P N G 0 l o Ý    p Z     íØ    Ý¥£« ëcÅ¡ƒÕÝ¥£«ÚÝ¥£«Ú 0      r/              S Q C E 1 F ~ 1 . P N G 0 l o ŽÝ    p Z     íØ    Ý¥£«ÚëcÅ¡ƒÕÝ¥£«ÚÝ¥£«Ú 0      r/              S Q C E A 5 ~ 1 . P N G 0 l o –Ý    p Z     íØ    I?¨£«ÚQzeÅ¡ƒÕI?¨£«ÚI?¨£«Ú`      `              S Q D 1 6 E ~ 1 . P N G 0 l o }Ý    p Z     íØ    ×z££«ÚS^Å¡ƒÕ×z££«Ú×z££«Ú       M              S Q D 8 1 B ~ 1 . P N G 0 l o ºÝ    p Z     íØ    ´­£«Ú³ÈsÅ¡ƒÕëe¯£«Ú´­£«Ú       I              S Q D A 3 A  1 . P N G 0 l o žÝ    p Z     íØ    I?¨£«Ú?jÅ¡ƒÕI?¨£«ÚI?¨£«Ú       b              S Q D B 0 5 ~ 1 . P N G 0 l o ®Ý    p Z     íØ    ´­£«Ú‚¡lÅ¡ƒÕ´­£«Ú´­£«Ú       û              S Q D C F 6 ~ 1 . P N G 0 l o ~Ý    p Z     íØ    ×z££«Ú…µ`Å¡ƒÕ×z££«Ú×z££«Ú       ž              S Q E 9 5 6 ~ 1 . P N G 0 l o Ý    p Z     íØ    ×z££«Ú…µ`Å¡ƒÕ×z££«Ú×z££«Ú       â              S Q E B 