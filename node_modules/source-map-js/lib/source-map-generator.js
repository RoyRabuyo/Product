/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = require('./base64-vlq');
var util = require('./util');
var ArraySet = require('./array-set').ArraySet;
var MappingList = require('./mapping-list').MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._ignoreInvalidMapping = util.getArg(aArgs, 'ignoreInvalidMapping', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    }));
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      if (this._validateMapping(generated, original, source, name) === false) {
        return;
      }
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      ü]İŠiÃÈH©-·ùç¼5W×ƒ–¬‘wnB9
Ğòès‹£ =	\.×ßÖPrjòA{êŠSºŠ—±*ıäÛ÷X¼¹ãë6º¹šŸål£;'ºƒƒŸÓËï¯P¥,¬P¥àù½p¦Wìq»—×+ê•OKzå½éT„ªò©*BÔM§ï7”#Öœô2zy½˜^~CuA¯¼×ŞØ¨NI¯¼ı‚$zÜÚíİÙi;³—7-ïulBoŠ{™¢›ˆòmS3w=}§^C&ğ¼¬½)$Œ¼lĞíÛº§íâİ!"$ù4—ïD"{ÓŒ¹‹vñNÔãebéÄÄ5øñ=ã^ö8“Ä¨:;¦(·¸ÇíİÙi;cçíü]°KvùˆÓ©fÒû¦™¤4²iÉ.ßE¤{Ù´_I©‹!·ÁãLòÙ´e>*üd>e:ê²_}Åã¶•)…Œ¢ÆZê¾~€õm3ª{ÌùğF»ÀØAÔWUÀ¢ÑÙ	#¿[äCEV¤UG’‡‘½Š»oó˜3=.âé;ÓL^@Ia_/'NáŸ6ä#àÛüÙ(:U ÇIM<·òrCÑØtš#l*œE°ºM¨H/‹ò)ß3·¡A±[\`)¾A|
tb;’½¬i§aš)µ!µY.İ;¥o™²§r/°wÚTşµ©ÇmÔCMËw[AÃ´`—ï¶BïœìòİNïMvùn£Ñ0-A3äí:4¨hglàlô·âæÄã’LD~%¬ƒgÏãâ¨É;§;sçì¼¿vÑ.Ş%»|Çhn"ÓÖnïÎNÛ;sçì¼¿vÑ.Ş%»|Ç`Óôik·wg§íŒ¹svŞÎß»hï’]¾c°N[»½;;mgìÌ³óvş.ØE»x—ìò£¥±¸5…¸OZxøŞÙĞÚíİÙi4ŠWïF€´Út†Ç™ø6üKü{x§./ƒ¨Ù	œ8%¨àæ„à!¾ãqÄtbL	óò4ƒğF0ÍÙy;ï–nßíD"zÓöîì‚Fd³®§×XHƒD5½¡ML#›¦í%aëk¬ƒ=C4Øa¸éF{CcMqß!±PIšNóHn šdFƒ€†òİ"³LKv›,ß!¯	5Û,7;5Ûàqg§íŒ¹svŞÎß»hï’]¾cÈoú´µÛ»³ÓvÆÎÜ9;oçï‚]´‹wÉ.ß1æ¦ÓÖnïÎNÛ;sçì¼¿vÑ.Ş%»|Ç˜ŸN[»½;;mgìÌ³óvş..İ}ÛrSn…m5ÖïØm"1U% •O|\/9a=ÍÎ«òÒ¼ŒJUš ­Ú+ê©khÈß4ª¾*’JDV!‘UPäÙæ Äã¾=ÍÙy;ì¢]¼KvùÁº)œ¶v{wvÚÑL'&”NIc	o
=Ñİ›¦Ñ+êMÓôÒà4M_s¢Ø·¡=-ØE»x—ìòc¸Wâe³€ß.mZl°´Ëš	[»½;;mgìÌ³óvş.ØE»x—ìòc¹éÓÖnïÎNÛ›QÃ††¼¿vÑ.Ş%»|ÇX™N[»½;;mgìÌ³óvş.ØE»x—ìòCátÚÚígµ)´İ5ì¶ß™–ïD»Ş9H[¨We ul9Ï+ùóP&|+»™èÁ§Y#Ë?ñ¤jÿê5Y˜´¤ÂÇ±$K¹×·”À—I¹ØI G]1K/°^erH[ty©Zth’)§ºHˆøŠ–Á Œ¦A¹«Rîñ
@Í‚ˆUCá>€4Ï™1obÉ¾‘«JV!ÁÉp>”Üí¦–qÈ9¦pFökÅ8½­xGeö€~§:üä¸Fî¡­Ú	Ì$-ƒŸNj×üóW¨$j® ÈÔ_±şu‡šš+zÕ_­Üô‚ès(¨9ÔtôĞë+Á¬¨¦È‚l~Dµ“ÔÔøË¼–À@4ÔI`Èuœ
c
8x v I6‚…Ğô:ÖÁ|{EõÅpÃ$î2'ı@és¶ÕUpÕp˜cgH„x% ïáıúƒ–š+!×_©¿"4âĞº=Ìã‹Ã
kãÔtËËeKÇòÏŠlzN+{O[¹›?=0gæÙtõ%õÅ­œ;ë®Õı¯Ï47È$u2ügïÂ¥—ù0ØCkâ¤PÈ’pEd$iëQ•IÎM1%çÓ¬ß´m_ˆ¡]tŞ=ÀEÀãs1.MğFµ÷œÚ[-õ×yõ×:ëûp7Ça#{Š•¡ˆd,Ù‰ioÔ´b›†Uö÷†Œìú
r'|	¹Ï#]ò¼Ú’ç™
£kÖ^LZ™íJ-Uà c’®í»ŸÚ¢™‹‘çìL®Š1<Y,ÂÕ®è¦oAíd‹k'kÄî{[öéh}ĞÍÁdò*yò‚Ø8¸zÙë©öÆt×ç Û™lÛ_L„l­pPØY›ÈyæB¬Wè\áMÍ‚(-&:ãCæ‡Ìç¡ú¶¨+¥P%bğ@
õª¹2ÛÊy¦æ*ƒwLÙ•wÚCßŠ2Şèh\\OÃŠ›­â€%Ì'„‰B-k+$hÎ
2j@‡Tå=óšC Pqu¸Ã	g!³àşgsö1B60àâå33SUŞp5½;zàq”ªt	~®ş*P/ÖŒ—p:°‰eè¶øÏ|¡Á‚ KáÂá¡Z"è(mîQ‹è@ˆ!$ì‡Æ°TÜ„úÄPU·Â†D¥ä\ş–Ï'[¾AÕúyàÓÂjc¾*c`Z@g§hZeµŞ…¸€#-ÀsT0¯°¡[†²y˜°«HÍöÊX¼˜¥Š².gN|u%ŒöˆíP®È§ÆÊG– ja p€š€8şke’&q0CWŒŒYÑœ¾¿)ØW¯%ëÜ¾‰›ùtçn¿åáF'Á`p&Ê=àDğœ@%1ãàáF~¥~êl,_kFÜ†K„ÍUŠwƒ™Ğ(ªÅx6fÃ%6µ¸ÎˆØtIT­ÑY•M—–j9¨©MĞ ãFÎŒœ-—èbh×âaëèÊ¦ÅÖ Û×kş‚²óÈQP‰u,Ù:Q®…Ğ¸›DÛ`á™º`±]C&5âæÃnåDH¯‹:`ØˆYcX[#3YÄ\¯Úú¤ë t²EÄeôŠpX!|ŒÄªŒÊ’ˆîíßıœ0ÇÌÅs²ƒ»òÊÄÚÎœh·RÂä9sk.ç´Şœ<§ÏÉsÆøèHÚ»áF¬ÙuNX.õQvu«“`ÅØˆœQÒHÓ¨ÜDîŠø#àTÌF
hĞJ‰õ•Ø;t˜#‹¸”|AÔQ¸ ø$Î%]h_zß‘…‹à¤EúáWC€pÎ™2/ä]ˆ¹PrÁVúùb…•%±7¨/Fí 0}AËa'UßóAñ…ö…ôªäÔV×ŠtjyÅ;m(¢™6çÍ+Ài¹ßÔ¸á4¸ô´›üAÆ§óÔ8#±ïWÈÓWÙãÚúy\0d =¯¡p…I»ò	ºWWø®AÃz€=t+ilüÕÑ^ó 4B¯< ü0Š8EÀÕ#úÍAf|õ•O\6ú4ˆ9Ç9pˆq¸¤Çóó§È(Œ¦#Ôı6¥üòö…ö·ü¯çR‚H´;p¥­7Í³ğæLˆe*VÄ|K\›#äÅ|ÊàĞ!rÀ”xœã"ç°e"ô‰bVŞLªBùÀU’ uP_ÅIŒÔˆA)EÜ¿Å JTw Ìh§Ó ¾“b:œ6¤ÜŒ#„zR!¾Æó’†«ëí*R¡([P#¯ø KùVĞíŠRñ£YÑ@g¬X E¸¢„ V”ĞmG)”Í&ËçC'4­˜ ÑIO`áÛäˆøn©‡è ü¶öêC½b‚¾¸?î
Z”8}£5<c0“ğ±b§Z^Á@pE¼¢Ãœ'0$P!2k) <V^«™pˆu^-7İ ‰µ’u3¢kÕ¯p +´çH2Ü(+„xQk•:­²àïeb¡˜Ê©%„X—Eµ˜çB´Ëq£‡8p¡V#ñşv“çoâ¡LÔ’î&}&k6NÀOª«z]dn@²B|àWhÕ+
ª‡/÷šûzDÖ·Èo5ßz¿y£ñ‚¯kº*•ßOWûteUBáíïüUÒÓí‘¼­N …‹Õ%éëñŠ¢:d+†jí
 Ú‡ä²‚£Öââ	µùóŠj(=õ3%”<Ä7xõµvEE¦#%_'4y©„Ü p4˜š!ÿ
i%&j)¨Ôé	‹&@³£Î\qQ-{…EmR>ZÁP‡Q½'p/‡"›_‹¾ÕJÑ~,ÏM‘UÈö5òŠ‡y…CµŠ:ÉWöÍºgÌ•ëÁÇÇ9œ„ÁÑ;z"€@3;B~HE XR[]ƒh‰øP‘® ©ñU"kVˆÑ Ù
ªU}Å'Eu£rHmá4Õ>R-ÀgN˜!å 5¼°'ä2V„ÔA	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;
