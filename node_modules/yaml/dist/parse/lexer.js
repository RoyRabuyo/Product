'use strict';

var cst = require('./cst.js');

/*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/
function isEmpty(ch) {
    switch (ch) {
        case undefined:
        case ' ':
        case '\n':
        case '\r':
        case '\t':
            return true;
        default:
            return false;
    }
}
const hexDigits = '0123456789ABCDEFabcdef'.split('');
const tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split('');
const invalidFlowScalarChars = ',[]{}'.split('');
const invalidAnchorChars = ' ,[]{}\n\r\t'.split('');
const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
/**
 * Splits an input string into lexical tokens, i.e. smaller strings that are
 * easily identifiable by `tokens.tokenType()`.
 *
 * Lexing starts always in a "stream" context. Incomplete input may be buffered
 * until a complete token can be emitted.
 *
 * In addition to slices of the original input, the following control characters
 * may also be emitted:
 *
 * - `\x02` (Start of Text): A document starts with the next token
 * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
 * - `\x1f` (Unit Separator): Next token is a scalar value
 * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
 */
class Lexer {
    constructor() {
        /**
         * Flag indicating whether the end of the current buffer marks the end of
         * all input
         */
        this.atEnd = false;
        /**
         * Explicit indent set in block scalar header, as an offset from the current
         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
         * explicitly set.
         */
        this.blockScalarIndent = -1;
        /**
         * Block scalars that include a + (keep) chomping indicator in their header
         * include trailing empty lines, which are otherwise excluded from the
         * scalar's contents.
         */
        this.blockScalarKeep = false;
        /** Current input */
        this.buffer = '';
        /**
         * Flag noting whether the map value indicator : can immediately follow this
         * node within a flow context.
         */
        this.flowKey = false;
        /** Count of surrounding flow collection levels. */
        this.flowLevel = 0;
        /**
         * Minimum level of indentation required for next lines to be parsed as a
         * part of the current scalar value.
         */
        this.indentNext = 0;
        /** Indentation level of the current line. */
        this.indentValue = 0;
        /** Position of the next \n character. */
        this.lineEndPos = null;
        /** Stores the state of the lexer if reaching the end of incpomplete input */
        this.next = null;
        /** A pointer to `buffer`; the current position of the lexer. */
        this.pos = 0;
    }
    /**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */
    *lex(source, incomplete = false) {
        if (source) {
            this.buffer = this.buffer ? this.buffer + source : source;
            this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? 'stream';
        while (next && (incomplete || this.hasChars(1)))
            next = yield* this.parseNext(next);
    }
    atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === ' ' || ch === '\t')
            ch = this.buffer[++i];
        if (!ch || ch === '#' || ch === '\n')
            return true;
        if (ch === '\r')
            return this.buffer[i + 1] === '\n';
        return false;
    }
    charAt(n) {
        return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
            let indent = 0;
            while (ch === ' ')
                ch = this.buffer[++indent + offset];
            if (ch === '\r') {
                const next = this.buffer[indent + offset + 1];
                if (next === '\n' || (!next && !this.atEnd))
                    return offset + indent + 1;
            }
            return ch === '\n' || indent >= this.indentNext || (!ch && !this.atEnd)
                ? offset + indent
                : -1;
        }
        if (ch === '-' || ch === '.') {
            const dt = this.buffer.substr(offset, 3);
            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))
                return -1;
        }
        return offset;
    }
    getLine() {
        let end = this.lineEndPos;
        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {
            end = this.buffer.indexOf('\n', this.pos);
            this.lineEndPos = end;
        }
        if (end === -1)
            return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === '\r')
            end -= 1;
        return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
        return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
    }
    peek(n) {
        return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
        switch (next) {
            case 'stream':
                return yield* this.parseStream();
            case 'line-start':
                return yield* this.parseLineStart();
            case 'block-start':
                return yield* this.parseBlockStart();
            case 'doc':
                return yield* this.parseDocument();
            case 'flow':
                return yield* this.parseFlowCollection();
            case 'quoted-scalar':
                return yield* this.parseQuotedScalar();
            case 'block-scalar':
                return yield* this.parseBlockScalar();
            case 'plain-scalar':
                return yield* this.parsePlainScalar();
        }
    }
    *parseStream() {
        let line = this.getLine();
        if (line === null)
            return this.setNext('stream');
        if (line[0] === cst.BOM) {
            yield* this.pushCount(1);
            line = line.substring(1);
        }
        if (line[0] === '%') {
            let dirEnd = line.length;
            const cs = line.indexOf('#');
            if (cs !== -1) {
                const ch = line[cs - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd = cs - 1;
            }
            while (true) {
                const ch = line[dirEnd - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd -= 1;
                el;  ;  ;  ;  ;  ;  ;  ;  ;  ÃÃÃÃÃÃÃÃHâ\$VHÉÏ ∂¬D∂⁄AÄ„$A∂ÛIãŸA∫   AÄ˚uÄ˙˜wE#¬A¡‡Aã¿È  ∂¿Lât$8Lç5á√ˇˇMãå∆ w  MÖ…uE#¬A¡‡Aã¿È‹   Hâ|$0A∂yHÖ€tAãA(âA∂√É¿ÄÉ¯`áÄ   HòA∂Ñî=  AãåÜÑ=  IŒˇ·ÃÃÃÃIãI ã¬¡Ë¡ÍHÖ…t∂¿∂∂“¡‚∂¿–¡‚◊÷Î8ã¬¡Í¡Ë∂»¡·∂¬ã—–ÎIãI¡ÍHÖ…t∂¬∂∂“¡‚A∂√–◊Hã|$0EÑ¬u+Ö“t"HãI:  HÖ…uIã	HãIHˇN  D  Dã–Aã¬Îã¬Lãt$8Hã\$@HÉƒ ^√Ãfê÷<  =  =  :=    ÃÃÃÃÃÃÃ@SVWAVHÉÏHHÉ=ä9   HãÚHã˘tLãrPÎLãr$IãHâ{HHÉ=i9   t'ãBA∏p   âCHã”HãQ9  HˇZ  D  È€  ÉJ Hâ¨$Ä   Lâ§$à   A«F    Lã#Lâ|$@A∂$$<uLLã=b8  MÖˇÑ  ãFA∏p   âCHã”IãOHˇ˜  D  Ö¿Ö`  AˇFHÉ√pMã?MÖˇu…È›   ãjã’ËÔ˘ˇˇÖ¿uLLã=8  MÖˇÑø   ãFA∏p   âCHã”IãOHˇù  D  Ö¿Ö  AˇFHÉ√pMã?MÖˇu…ÈÉ   HÖˇuE3ˇÎHçOpHˇÓ  D  Lãøò   Lã≈Iã‘IãœËi‡ˇˇ3€ÖÌt9ãÀLçL$xIœLçD$pã’Ëà˙ˇˇÉËtÉ¯ÎãT$xE3…E3¿Ëõ¸ˇˇãD$pÿ+Ëu«HÖˇtHçOpHˇ}  D  Hã17  ∫ˇˇˇˇHˇM  D  Hã7  Aã^Hˇ^  D  Ö€u9ÉNAπ…  HãG∑W"LãGHãOH«D$0    Hât$(HâD$ Hˇa  D  3¿Lã§$à   Hã¨$Ä   Lã|$@HÉƒHA^_^[√ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃHÉÏHA∏…  fA;–ufMÖ…Ñ∫   HÉ='7   MãQHIãIPtãAÎHãA$É@ˇÖï   ãA® Öä   É‡˚H«D$0    É»HâL$(âAEã»A∑R"IãBMãBIãJÎLA∫   fA;“uQMÖ…tLHÉ=π6   IãIHMãAPt:AãA,Eã Aâ@,∑Q"HãAH«D$0    LâD$(LãAHãIHâD$ HˇZ  D  HÉƒH√ÃÃÃÃÃÃÃÃHâ\$Hâl$Hât$ WHÉÏ HãBP«D$0    Hã0HãB$Hã>HâF$ãZâ^HâNHÖ€tnÉ˚Çó   É√¸É˚Çã   ãO∂oÅ·ˇˇˇ @ÑÌuLçL$0A∏   ã—Ëá˙ˇˇã»ãD$0âGâOÉ√¸É˚rSHÉ«É√¸@ÑÌyÉ¡É·¸;Ÿr=ã¡H¯+ŸÖ€uíHã∑5  A∏p   Hã÷Hˇü  D  Hã\$8Hãl$@Hãt$HHÉƒ _√Ã∏   Î„                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             pppk   qpk                                                                                         ppk                   pSpk   xSpk   ®Spk           u                                                                                                                                    b              d       d              bb              pb      öb      ®b      ~b              ƒb      äb      “b              ∂b              :d      hc      ~c      Nd              Nc              “c      Ïc      æc              <b      c      .c      ˙b      ‚b      Rb      ,b              Fc              îc      Æc              §g              äf      vg      fg      Rg      @g      .g      g      g      ˛e      f      &f      >f      f      ff      xf      Lf      ûf      ¥f      ƒf      ﬁf              æa      Ãa      ‘a      ﬁa      ∞a      Ía      ‘g              Äpk   ‡pk                           @pk                @   ¿   Ä   –   P@        L o c a l \ M i d i M a p p e r _ m o d L o n g M e s s a g e _ R e f C n t         ‹       $   xT  x<      ‹       t  úT  ú<      ‹       $   W  ?      RSDS*y4tfÁTµ®GP¢   midimap.pdb  UGP   @  .text$lp00midimap.dll!30_clientonly @  ê
  .text$mn    –      .text$mn$00      .text$x #  Ä  .text$zy    ê(  É  .text$zz     P  (  .rdata$brc  (Q  H  .idata$5    pS     .00cfg  ÄS     .CRT$XCA    àS     .CRT$XCZ    êS     .CRT$XIA    òS     .CRT$XIAA   †S     .CRT$XIZ    ®S  (   .gfids  –S  ®   .rdata  xT  ¿  .rdata$zzzdbg   8W  x  .xdata  ∞]  x   .edata  (^  ,  .idata$2    T_     .idata$3    h_  H  .idata$4    ∞a  .  .idata$6     p      .data    p  @   .data$zz    `p  Ä  .bss    ‡v  ∏   .bss$00 òw     .bss$pr00   †w      .bss$zz  Ä  P  .pdata   ê  ∞  .rsrc$01    ∞ë    .rsrc$02        *y4tfÁTµ®GP¢»≠ŒFW_Ω≤0ö‹     í0! ‰ t 
d T   $  8W  ! ‘ $  T  @W  ! Ù T  Y  `W  ! ƒ	 Y  C  tW  !   Y  C  tW  !   T  Y  `W  !   $  T  @W  !     $  8W  !   Ù  ‰  ‘  t  d  T   $  8W  !   ‰  t  d  T   $  8W  !     $  8W  !   ‰  t  d  T #  #  $X  !   Ù  ‰  ‘  t  d  T #  #  $X  !   Ù  ‰  ‘  ƒ	  t  d  T #  #  $X    –! t d    :  ®X  ! 4 :  ©  ¥X  ! ‰ ƒ T ©  ¿  ÃX  !   ©  ¿  ÃX  !   :  ©  ¥X  !      :  ®X  !      :  ®X  !   ‰  ƒ  t  d  T  4 X'  :(  ,Y  
 d
 T	 4 2‡¿ 41 * ‡p`  j  	   i  ì    ì  ≥  Õ  D   Õ  Ì    ò     /  >  Ï   >  V  e  @!  e  â  ô  î!  ô  ∫  ‘  Ò!  ‘      W"    1  ,  Ω"       2P   	
 
4 
2pj     ˝  0  "  0   4	 2P          B   20
 
B–p`0  ! Ù ‰ ƒ T
 î(  )  ÑZ  !   î(  )  ÑZ  !   Ù  ‰  ƒ  T
 î(  )  ÑZ  !   î(  )  ÑZ  
 t	 d T 4 2	 	20 d 4 2p
 
d 
rp! 4
 h,  ±,  $[  !   h,  ±,  $[   T 4 2p! d ‡6  ç7  T[  !   ‡6  ç7  T[   t d
 T	 4 2‡¿&	 T  ‡	¿p`  @  Ä   ! 4 D0  è0  §[  !   D0  è0  §[  !   4 D0  è0  §[  !   D0  è0  §[  * 4(  ‡–
¿p`P  @  ‡   
 
4 
2`! t T Ã8  Á8  0\  !   Ã8  Á8  0\   0  !   t d T  :  :  d\  !    :  :  d\  
 
Ç‡p`0  !   Ù ƒ T ¸=  \>  ò\  !   ¸=  \>  ò\  
 
4 
2`! ‰ ,<  m<  ‘\  ! t m<  ï<  ‡\  !   m<  ï<  ‡\  !   ,<  m<  ‘\   2p! 4 ê9  ¶9  (]  !   ê9  ¶9  (]   20! t D8  Z8  T]  !   D8  Z8  T]   Ç   d	 T 4 2p 0                  ‹    ˆ]           ÿ]  ‰]  ]       P@  ^  ^  ^      MIDIMAP.dll DriverProc modMessage modmCallback    pa          b  0S  h_          b  (Q  P`          bd  R  ê_          Ñd  PQ  †_          ¶d  `Q  »_          ∆d  àQ  Ë_          d  ®Q  ê`          e  PR   `          <e  ‡Q  ¯_          `e  ∏Q  †`          äe  `R  0`          Æe  Q  x_          ‘e  8Q  »`          Üg  àR  ∏`          ∂g  xR                      b              d       d              bb              pb      öb      ®b      ~b              ƒb      äb      “b              ∂b              :d      hc      ~c      Nd              Nc              “c      Ïc      æc              <b      c      .c      ˙b      ‚b      Rb      ,b              Fc              îc      Æc              §g              äf      vg      fg      Rg      @g      .g      g      g      ˛e      f      &f      >f      f      ff      xf      Lf      ûf      ¥f      ƒf      ﬁf              æa      Ãa      ‘a      ﬁa      ∞a      Ía      ‘g              U _XcptFilter Æ _amsg_exit  Lfree  Ümalloc  }_initterm W __C_specific_handler  msvcrt.dll   DefDriverProc WINMMBASE.dll 
 CreateMutexW  6 WaitForSingleObject # ReleaseMutex    CloseHandle  LocalAlloc  
 LocalFree  GlobalHandle    GlobalAlloc  GlobalFree   LoadStringW  GlobalLock   GlobalUnlock   EnterCriticalSection   LeaveCriticalSection   InitializeCriticalSection  DeleteCriticalSection - Sleep   QueryPerformanceCounter  GetCurrentProcessId  GetCurrentThreadId   GetSystemTimeAsFileTime  GetTickCount  ÚRtlCaptureContext ËRtlLookupFunctionEntry  'RtlVirtualUnwind   UnhandledExceptionFilter   SetUnhandledExceptionFilter  GetCurrentProcess N TerminateProcess  api-ms-win-core-synch-l1-1-0.dll  api-ms-win-core-handle-l1-1-0.dll api-ms-win-core-heap-l2-1-0.dll api-ms-win-core-heap-obsolete-l1-1-0.dll  api-ms-win-core-libraryloader-l1-2-0.dll  api-ms-win-core-synch-l1-2-0.dll  api-ms-win-core-profile-l1-1-0.dll  api-ms-win-core-processthreads-l1-1-0.dll api-ms-win-core-sysinfo-l1-1-0.dll  api-ms-win-core-rtlsupport-l1-1-0.dll api-ms-win-core-errorhandling-l1-1-0.dll  " midiOutMessage   midiOutGetDevCapsW  $ midiOutPrepareHeader  # midiOutOpen ( midiOutUnprepareHeader  * midiStreamOpen  ) midiStreamClose & midiOutSetVolume  - midiStreamPosition   midiOutClose   midiOutCacheDrumPatches 0 midiStreamStop   midiOutCachePatches . midiStreamProperty  , midiStreamPause ' midiOutShortMsg ! midiOutLongMsg  / midiStreamRestart % midiOutReset  + midiStreamOut api-ms-win-mm-mme-l1-1-0.dll   DriverCallback  api-ms-win-mm-misc-l1-1-0.dll ímemcpy                                    eld* this.pushUntil(ch => isEmpty(ch) || ch === '#');
    }
    *parseBlockScalar() {
        let nl = this.pos - 1; // may be -1 if this.pos === 0
        let indent = 0;
        let ch;
        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {
            switch (ch) {
                case ' ':
                    indent += 1;
                    break;
                case '\n':
                    nl = i;
                    indent = 0;
                    break;
                case '\r': {
                    const next = this.buffer[i + 1];
                    if (!next && !this.atEnd)
                        return this.setNext('block-scalar');
                    if (next === '\n')
                        break;
                } // fallthrough
                default:
                    break loop;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('block-scalar');
        if (indent >= this.indentNext) {
            if (this.blockScalarIndent === -1)
                this.indentNext = indent;
            else
                this.indentNext += this.blockScalarIndent;
            do {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = this.buffer.indexOf('\n', cs);
            } while (nl !== -1);
            if (nl === -1) {
                if (!this.atEnd)
                    return this.setNext('block-scalar');
                nl = this.buffer.length;
            }
        }
        if (!this.blockScalarKeep) {
            do {
                let i = nl - 1;
                let ch = this.buffer[i];
                if (ch === '\r')
                    ch = this.buffer[--i];
                const lastChar = i; // Drop the line if last char not more indented
                while (ch === ' ' || ch === '\t')
                    ch = this.buffer[--i];
                if (ch === '\n' && i >= this.pos && i + 1 + indent > lastChar)
                    nl = i;
                else
                    break;
            } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while ((ch = this.buffer[++i])) {
            if (ch === ':') {
                const next = this.buffer[i + 1];
                if (isEmpty(next) || (inFlow && next === ','))
                    break;
                end = i;
            }
            else if (isEmpty(ch)) {
                let next = this.buffer[i + 1];
                if (ch === '\r') {
                    if (next === '\n') {
                        i += 1;
                        ch = '\n';
                        next = this.buffer[i + 1];
                    }
                    else
                        end = i;
                }
                if (next === '#' || (inFlow && invalidFlowScalarChars.includes(next)))
                    break;
                if (ch === '\n') {
                    const cs = this.continueScalar(i + 1);
                    if (cs === -1)
                        break;
                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'
                }
            }
            else {
                if (inFlow && invalidFlowScalarChars.includes(ch))
                    break;
                end = i;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('plain-scalar');
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? 'flow' : 'doc';
    }
    *pushCount(n) {
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos += n;
            return n;
        }
        return 0;
    }
    *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
            yield s;
            this.pos += s.length;
            return s.length;
        }
        else if (allowEmpty)
            yield '';
        return 0;
    }
    *pushIndicators() {
        switch (this.charAt(0)) {
            case '!':
                return ((yield* this.pushTag()) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '&':
                return ((yield* this.pushUntil(isNotAnchorChar)) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '-': // this is an error
            case '?': // this is an error outside flow collections
            case ':': {
                const inFlow = this.flowLevel > 0;
                const ch1 = this.charAt(1);
                if (isEmpty(ch1) || (inFlow && invalidFlowScalarChars.includes(ch1))) {
                    if (!inFlow)
                        this.indentNext = this.indentValue + 1;
                    else if (this.flowKey)
                        this.flowKey = false;
                    return ((yield* this.pushCount(1)) +
                        (yield* this.pushSpaces(true)) +
                        (yield* this.pushIndicators()));
                }
            }
        }
        return 0;
    }
    *pushTag() {
        if (this.charAt(1) === '<') {
            let i = this.pos + 2;
            let ch = this.buffer[i];
            while (!isEmpty(ch) && ch !== '>')
                ch = this.buffer[++i];
            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);
        }
        else {
            let i = this.pos + 1;
            let ch = this.buffer[i];
            while (ch) {
                if (tagChars.includes(ch))
                    ch = this.buffer[++i];
                else if (ch === '%' &&
                    hexDigits.includes(this.buffer[i + 1]) &&
                    hexDigits.includes(this.buffer[i + 2])) {
                    ch = this.buffer[(i += 3)];
                }
                else
                    break;
            }
            return yield* this.pushToIndex(i, false);
        }
    }
    *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === '\n')
            return yield* this.pushCount(1);
        else if (ch === '\r' && this.charAt(1) === '\n')
            return yield* this.pushCount(2);
        else
            return 0;
    }
    *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
            ch = this.buffer[++i];
        } while (ch === ' ' || (allowTabs && ch === '\t'));
        const n = i - this.pos;
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos = i;
        }
        return n;
    }
    *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
            ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
    }
}

exports.Lexer = Lexer;
