'use strict';

var cst = require('./cst.js');
var lexer = require('./lexer.js');

function includesToken(list, type) {
    for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
            return true;
    return false;
}
function findNonEmptyIndex(list) {
    for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
            case 'space':
            case 'comment':
            case 'newline':
                break;
            default:
                return i;
        }
    }
    return -1;
}
function isFlowToken(token) {
    switch (token?.type) {
        case 'alias':
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'flow-collection':
            return true;
        default:
            return false;
    }
}
function getPrevProps(parent) {
    switch (parent.type) {
        case 'document':
            return parent.start;
        case 'block-map': {
            const it = parent.items[parent.items.length - 1];
            return it.sep ?? it.start;
        }
        case 'block-seq':
            return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
            return [];
    }
}
/** Note: May modify input array */
function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
        return [];
    let i = prev.length;
    loop: while (--i >= 0) {
        switch (prev[i].type) {
            case 'doc-start':
            case 'explicit-key-ind':
            case 'map-value-ind':
            case 'seq-item-ind':
            case 'newline':
                break loop;
        }
    }
    while (prev[++i]?.type === 'space') {
        /* loop */
    }
    return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
    if (fc.start.type === 'flow-seq-start') {
        for (const it of fc.items) {
            if (it.sep &&
                !it.value &&
                !includesToken(it.start, 'explicit-key-ind') &&
                !includesToken(it.sep, 'map-value-ind')) {
                if (it.key)
                    it.value = it.key;
                delete it.key;
                if (isFlowToken(it.value)) {
                    if (it.value.end)
                        Array.prototype.push.apply(it.value.end, it.sep);
                    else
                        it.value.end = it.sep;
                }
                else
                    Array.prototype.push.apply(it.start, it.sep);
                delete it.sep;
            }
        }
    }
}
/**
 * A YAML concrete syntax tree (CST) parser
 *
 * ```ts
 * const src: string = ...
 * for (const token of new Parser().parse(src)) {
 *   // token: Token
 * }
 * ```
 *
 * To use the parser with a user-provided lexer:
 *
 * ```ts
 * function* parse(source: string, lexer: Lexer) {
 *   const parser = new Parser()
 *   for (const lexeme of lexer.lex(source))
 *     yield* parser.next(lexeme)
 *   yield* parser.end()
 * }
 *
 * const src: string = ...
 * const lexer = new Lexer()
 * for (const token of parse(src, lexer)) {
 *   // token: Token
 * }
 * ```
 */
class Parser {
    /**
     * @param onNewLine - If defined, called separately with the start position of
     *   each new line (in `parse()`, including the start of input).
     */
    constructor(onNewLine) {
        /** If true, space and sequence indicators count as indentation */
        this.atNewLine = true;
        /** If true, next token is a scalar value */
        this.atScalar = false;
        /** Current indentation level */
        this.indent = 0;
        /** Current offset since the start of parsing */
        this.offset = 0;
        /** On the same line with a block map key */
        this.onKeyLine = false;
        /** Top indicates the node that's currently being built */
        this.stack = [];
        /** The source of the current token, set in parse() */
        this.source = '';
        /** The type of the current token, set in parse() */
        this.type = '';
        // Must be defined after `next()`
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
    }
    /**
     * Parse `source` as a YAML stream.
     * If `incomplete`, a part of the last line may be left as a buffer for the next call.
     *
     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
     *
     * @returns A generator of tokens representing each directive, document, and other structure.
     */
    *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
            this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
            yield* this.next(lexeme);
        if (!incomplete)
            yield* this.end();
    }
    /**
     * Advance the parser by the `source` of one lexical token.
     */
    *next(source) {
        this.source = source;
        if (process.env.LOG_TOKENS)
            console.log('|', cst.prettyToken(source));
        if (this.atScalar) {
            this.atScalar = false;
            yield* this.step();
            this.offset += source.length;
            return;
        }
        const type = cst.tokenType(source);
        if (!type) {
            const message = `Not a YAML token: ${source}`;
            yield* this.pop({ type: 'error', offset: this.offset, message, source });
            this.offset += source.length;
        }
        else if (type === 'scalar') {
            this.atNewLine = false;
            this.atScalar = true;
            this.type = 'scalar';
        }
        else {
            this.type = type;
            yield* this.step();
            switch (type) {
                case 'newline':
                    this.atNewLine = true;
                    this.indent = 0;
                    if (this.onNewLine)
                        this.onNewLine(this.offset + source.length);
                    break;
                case 'space':
                    if (this.atNewLine && source[0] === ' ')
                        this.indent += source.length;
                    break;
                case 'explicit-key-ind':
                case 'map-value-ind':
                case 'seq-item-ind':
                    if (this.atNewLine)
                        this.indent += source.length;
                    break;
                case 'doc-mode':
                case 'flow-error-end':
                    return;
                default:
                    this.atNewLine = false;
            }
            this.offset += source.length;
        }
    }
    /** Call at end of input to push out any remaining constructions */
    *end() {
        while (this.stack.length > 0)
            yield* this.pop();
    }
    get sourceToken() {
        const st = {
            type: this.type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
        return st;
    }
    *step() {
        const top = this.peek(1);
        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {
            while (this.stack.length > 0)
                yield* this.pop();
            this.stack.push({
                type: 'doc-end',
                offset: this.offset,
                source: this.source
            });
            return;
        }
        if (!top)
            return yield* this.stream();
        switch (top.type) {
            case 'document':
                return yield* this.document(top);
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return yield* this.scalar(top);
            case 'block-scalar':
                return yield* this.blockScalar(top);
            case 'block-map':
                return yield* this.blockMap(top);
            case 'block-seq':
                return yield* this.blockSequence(top);
            case 'flow-collection':
                return yield* this.flowCollection(top);
            case 'doc-end':
                return yield* this.documentEnd(top);
        }
        /* istanbul ignore next should not happen */
        yield* this.pop();
    }
    peek(n) {
        return this.stack[this.stack.length - n];
    }
    *pop(error) {
        const token = error ?? this.stack.pop();
        /* istanbul ignore if should not happen */
        if (!token) {
            const message = 'Tried to pop an empty stack';
            yield { type: 'error', offset: this.offset, source: '', message };
        }
        else if (this.stack.length === 0) {
            yield token;
        }
        else {
            const top = this.peek(1);
            if (token.type === 'block-scalar') {
                // Block scalars use their parent rather than header indent
                token.indent = 'indent' in top ? top.indent : 0;
            }
            else if (token.type === 'flow-collection' && top.type === 'document') {
                // Ignore all indent for top-level flow collections
                token.indent = 0;
            }
            if (token.type === 'flow-collection')
                fixFlowSeqItems(token);
            switch (top.type) {
                case 'document':
                    top.value = token;
                    break;
                case 'block-scalar':
                    top.props.push(token); // error
                    break;
                case 'block-map': {
                    const it = top.items[top.items.length - 1];
                    if (it.value) {
                        top.items.push({ start: [], key: token, sep: [] });
                        this.onKeyLine = true;
                        return;
                    }
                    else if (it.sep) {
                        it.value = token;
                    }
                    else {
                        Object.assign(it, { key: token, sep: [] });
                        this.onKeyLine = !includesToken(it.start, 'explicit-key-ind');
                        return;
                    }
                    break;
                }
                case 'block-seq': {
                    const it = top.items[top.items.length - 1];
                    if (it.value)
                        top.items.push({ start: [], value: token });
                    else
                        it.value = token;
                    break;
                }
                case 'flow-collection': {
                    const it = top.items[top.items.length - 1];
                    if (!it || it.value)
                        top.items.push({ start: [], key: token, sep: [] });
                    else if (it.sep)
                        it.value = token;
                    else
                        Object.assign(it, { key: token, sep: [] });
                    return;
                }
                /* istanbul ignore next should not happen */
                default:
                    yield* this.pop();
                    yield* this.pop(token);
            }
            if ((top.type === 'document' ||
                top.type === 'block-map' ||
                top.type === 'block-seq') &&
                (token.type === 'block-map' || token.type === 'block-seq')) {
                const last = token.items[token.items.length - 1];
                if (last &&
                    !last.sep &&
                    !last.value &&
                    last.start.length > 0 &&
                    findNonEmptyIndex(last.start) === -1 &&
                    (token.indent === 0 ||
                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {
                    if (top.type === 'document')
                        top.end = last.start;
                    else
                        top.items.push({ start: last.start });
                    token.items.splice(-1, 1);
                }
            }
        }
    }
    *stream() {
        switch (this.type) {
            case 'directive-line':
                yield { type: 'directive', offset: this.offset, source: this.source };
                return;
            case 'byte-order-mark':
            case 'space':
            case 'comment':
            case 'newline':
                yield this.sourceToken;
                return;
            case 'doc-mode':
            case 'doc-start': {
                const doc = {
                    type: 'document',
                    offset: this.offset,
                    start: []
                };
                if (this.type === 'doc-start')
                    doc.start.push(this.sourceToken);
                this.stack.push(doc);
                return;
            }
        }
        yield {
            type: 'error',
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML stream`,
            source: this.source
        };
    }
    *document(doc) {
        if (doc.value)
            return yield* this.lineEnd(doc);
        switch (this.type) {
            case 'doc-start': {
                if (findNonEmptyIndex(doc.start) !== -1) {
                    yield* this.pop();
                    yield* this.step();
                }
                else
                    doc.start.push(this.sourceToken);
                return;
            }
            case 'anchor':
            case 'tag':
            case 'space':
            case 'comment':
            case 'newline':
                doc.start.push(this.sourceToken);
                return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
            this.stack.push(bv);
        else {
            yield {
                type: 'error',
                offset: this.offset,
                message: `Unexpected ${this.type} token in YAML document`,
                source: this.source
            };
        }
    }
    *scalar(scalar) {
        if (this.type === 'map-value-ind') {
            const prev = getPrevProps(this.peek(2));
            const start = getFirstKeyStartProps(prev);
            let sep;
            if (scalar.end) {
                sep = scalar.end;
                sep.push(this.sourceToken);
                delete scalar.end;
            }
            else
                sep = [this.sourceToken];
            const map = {
                type: 'block-map',
                offset: scalar.offset,
                indent: scalar.indent,
                items: [{ start, key: scalar, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
        }
        else
            yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
        switch (this.type) {
            case 'space':
            case 'comment':
            case 'newline':
                scalar.props.push(this.sourceToken);
                return;
            case 'scalar':
                scalar.source = this.source;
                // block-scalar source includes trailing newline
                this.atNewLine = true;
                this.indent = 0;
                if (this.onNewLine) {
                    let nl = this.source.indexOf('\n') + 1;
                    while (nl !== 0) {
                        this.onNewLine(this.offset + nl);
                        nl = this.source.indexOf('\n', nl) + 1;
                    }
                }
                yield* this.pop();
                break;
            /* istanbul ignore next should not happen */
            default:
                yield* this.pop();
                yield* this.step();
        }
    }
    *blockMap(map) {
        const it = map.items[map.items.length - 1];
        // it.sep is true-ish if pair already has key or : separator
        switch (this.type) {
            case 'newline':
                this.onKeyLine = false;
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    it.start.push(this.sourceToken);
                }
                return;
            case 'space':
            case 'comment':
                if (it.value) {
                    map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    if (this.atIndentedComment(it.start, map.indent)) {
                        const prev = map.items[map.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            map.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
        }
        if (this.indent >= map.indent) {
            const atNextItem = !this.onKeyLine &&
                this.indent === map.indent &&
                it.sep &&
                this.type !== 'seq-item-ind';
            // For empty nodes, assign newline-separated not indented empty tokens to following node
            let start = [];
            if (atNextItem && it.sep && !it.value) {
                const nl = [];
                for (let i = 0; i < it.sep.length; ++i) {
                    const st = it.sep[i];
                    switch (st.type) {
                        case 'newline':
                            nl.push(i);
                            break;
                        case 'space':
                            break;
                        case 'comment':
                            if (st.indent > map.indent)
                                nl.length = 0;
                            break;
                        default:
                            nl.length = 0;
                    }
                }
                if (nl.length >= 2)
                    start = it.sep.splice(nl[1]);
            }
            switch (this.type) {
                case 'anchor':
                case 'tag':
                    if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        it.sep.push(this.sourceToken);
                    }
                    else {
                        it.start.push(this.sourceToken);
                    }
                    return;
                case 'explicit-key-ind':
                    if (!it.sep && !includesToken(it.start, 'explicit-key-ind')) {
                        it.start.push(this.sourceToken);
                    }
                    else if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                    }
                    else {
                        this.stack.push({
                            type: 'block-map',
                            offset: this.offset,
                            indent: this.indent,
                            items: [{ start: [this.sourceToken] }]
                        });
                    }
                    this.onKeyLine = true;
                    return;
                case 'map-value-ind':
                    if (includesToken(it.start, 'explicit-key-ind')) {
                        if (!it.sep) {
                            if (includesToken(it.start, 'newline')) {
                                Object.assign(it, { key: null, sep: [this.sourceToken] });
                            }
                            else {
                                const start = getFirstKeyStartProps(it.start);
                                this.stack.push({
                                    type: 'block-map',
                                    offset: this.offset,
                                    indent: this.indent,
                                    items: [{ start, key: null, sep: [this.sourceToken] }]
                                });
                            }
                        }
                        else if (it.value) {
                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else if (isFlowToken(it.key) &&
                            !includesToken(it.sep, 'newline')) {
                            const start = getFirstKeyStartProps(it.start);
                            const key = it.key;
                            const sep = it.sep;
                            sep.push(this.sourceToken);
                            // @ts-expect-error type guard is wrong here
                            delete it.key, delete it.sep;
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key, sep }]
                            });
                        }
                        else if (start.length > 0) {
                            // Not actually at next item
                            it.sep = it.sep.concat(start, this.sourceToken);
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    else {
                        if (!it.sep) {
                            Object.assign(it, { key: null, sep: [this.sourceToken] });
                        }
                        else if (it.value || atNextItem) {
                            map.items.push({ start, key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start: [], key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    this.onKeyLine = true;
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (atNextItem || it.value) {
                        map.items.push({ start, key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        this.stack.push(fs);
                    }
                    else {
                        Object.assign(it, { key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    return;
                }
                default: {
                    const bv = this.startBlockValue(map);
                    if (bv) {
                        if (atNextItem &&
                            bv.type !== 'block-seq' &&
                            includesToken(it.start, 'explicit-key-ind')) {
                            map.items.push({ start }EÄPEÀPE¼PE¸PQj ‹Îè’©ÿÿ^ÉÂ Ì‹ÿU‹ìƒäø€} uƒyu
ÿuèşÿÿëƒyuÿuèéşÿÿ‹å]Â ‹ÿQ€y Ç  t‹I‹A‹Qƒ! ƒa ƒa PRÿpTYÃÌ‹ÿU‹ìQQEøPEüPjhĞDÿDT…Àt ƒ}ü uVW‹}øj ‹‹p‹ÎÿÄT‹ÏÿÖ_^ÉÃ‹ÿU‹ìƒäøQQƒ$$ $SVPD$»ĞDPj SÿDT…ÀtDƒ|$ t=ÇD$ÔDÇÔD  h€¼ ÇäD8@è1s  Y¾ÔD‹ÎèüÿÿVj SÿHT‹D$^[‹@‹å]Ã‹ÿU‹ìƒäø‹Q8ƒìTVƒú|+‹A<…Àx‹E‰A<‹u…öt‰‹Q8Bÿ…À‰A8^”À‹å]Â jPD$j Pè@{  ƒÄL$èµÿÿÌ‹ÿU‹ìƒäøQSV‹ñ3ÛW¾¸   Ç 9t5D$Pèîùÿÿ‹…Àt	ƒ8u³ë‹Ïè:ûÿÿƒ|$ t
ÿt$ÿ T„Ût&‹Nƒ9u‹AD…Àx¸>€T$RPè2ÿÿÿ‹Îè÷ÿÿ‹Îèoùÿÿ_^[‹å]ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìV‹ñè˜   öEt‹Îè°Éÿÿ‹Æ^]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌl$„   é“   ÌÌÌl$ˆ   éƒ   ÌÌÌ‹ÿU‹ìÿu‹EƒÀPÿ S3À]Â ÌÌÌÌÌ‹ÿU‹ì‹U‹Eƒ" ‹H…Ét‹VRÿu‹0Q‹ÎÿÄTÿÖ^ë¸@ €]Â Ç0 Ç„   ä Çˆ   ğ ÿ%PRÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìÿuÿuhT ÿuÿS]Â ÌÌÌ‹ÿU‹ìSVW‹ñj[Çü ~‹ÏèÌÆÿÿƒÇƒëuñöEÇ˜ t‹Îè¢Èÿÿ_‹Æ^[]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìSVW‹ùÿ¸Tj‰‡¬   3ÛGYˆ@ƒéuö‰Ÿ¨   9_t%‹M…Ét‰O‹Q‹p‹ÎÿÄTÿÖ‹Ïèœ   ‹ğë¾@ €…öˆ‚   hÜ> ÿ R‹O·ÀPÿR…ÀtÇ€Ø   àÂ ‰¸Ü   jÿĞR…ÀtJhü> ÿ R‹O·ÀPÿR…Àt	S‹ÈÿRh? ÿ R‹O·ÀPÿR…Àt	S‹ÈÿR_‹Æ^[]Â ‹ÿU‹ìƒì‹ÁW‰Eğ¿@ €‹P…Ò„¢   ‹MôVQR‹p‹ÎÿÄTÿÖ‹ø…ÿˆ‚   ‹EôUøƒeø RP‹‹q‹ÎÿÄTÿÖ‹ø…ÿxNS3Û9]øvE‹EôMüƒeü QS‹0P‹NÿÄTÿV‹ø…ÿxÿuü‹Mğè§   ‹EüP‹‹q‹ÎÿÄTÿÖC;]ør»[‹EôP‹‹q‹ÎÿÄTÿÖ^‹Ç_ÉÃ‹ÿU‹ìQQSV3À‰MüWY‰Eøƒ; tEÿ° ‹q3ÿGÿ R·À‹ÎPÿR…Àt
¶xdÁïƒç‹Müƒ÷‹j W‹Iè<  ‹Eø‹MüƒÀƒÃ‰EøƒøHr¨_^3À[ÉÃ‹ÿU‹ìƒìSVW‹}‰MüMøQW‹‹p ‹ÎÿÄTÿÖ3ÛC…Ày‰]ø‹MôQW‹p8‹ÎÿÄTÿÖ…Ày‰]ô‹MìQW‹p‹ÎÿÄTÿÖ…ÀˆÎ   3Ûj jÿÿ4@ jÿÿuìÿTƒøtCƒûrßé   ‹uü‹×‹Nè`;  …Àu-ÿ4 ‹vÿ R·À‹ÎPÿR…Àt
j ‹Èÿ(R‹uü‹Ïèå;  …Àu9Eøt	ÆEğ9EôtÆEğ ÿ4 ‹vÿ R·À‹ÎPÿR…Àtÿuğ‹Èÿ$R‹MüW‰|Ù‹‹p‹ÎÿÄTÿÖÿuìÿXS_^3À[ÉÂ ÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìQVW‹}3ö…ÿt^ƒ}NuXƒütƒşuLEüº  P¹@4 èŞÿÿ…Àx5‹Eüºp+ ƒÀ>Gè;H  …Àx‹E…Àt9°¬   tQQèù  ‹M3öF‰1_‹Æ^ÉÂ ÌÌÌÌÌÌÌÌÌ‹ÿU‹ìQV‹uW‹ùƒ~ubEüPÿ@R‹ ;FuQ‹SÆFh0? ·X`ÿ Rf;Ãu‹Ïèıÿÿj ÿw3Ò3ÉèGY  ëh8? ÿ Rf;Ãu
‹Oè[  ëÆF [_^ÉÂ ‹ÿV‹ò…Éu¹D9 QÿœR‰÷Ø^À%òÿø €Ã‹ÿVW‹ù3öj ·Æjÿÿ4… jÿWÿTƒøtFfƒşrİ3Àë3À@_^Ã‹ÿVW‹ù3öj ·Æjÿÿ4…` jÿWÿTƒøtFfƒşrİ3Àë3À@_^Ã‹ÿVW‹ù3öj ·Æjÿÿ4…@ jÿWÿTƒøtFfƒşrİ3Àë3À@_^Ã‹ÿSVWj‹ù3ö[j ·Æjÿÿ4…0 jÿWÿT;Ãt
Ff;órß3Àë3À@_^[Ã‹ÿU‹ìQQS‹ÙMüVQS‹‹p‹ÎÿÄTÿÖ…ÀxS‹MüWègÿÿÿ…Àu‹Müèÿÿÿ…Àu3ÿë3ÿGÿuüÿXS‹MøQS‹p8‹ÎÿÄTÿÖ…Àxƒ}ø u…ÿt3ÿG‹Ç_ë3À^[ÉÃ‹ÿU‹ìì  ¡„@3Å‰EüS‹]…äıÿÿVW‹ú‹ñPºÿÿÿè¥Ûÿÿ…ÀxF‹E9…äıÿÿv2PVèıÿÿè  …Àx*…ÿtWº	  èıÿÿèg¤ÿÿ…Àxèıÿÿë‹Î‹Óèşÿÿ‹Mü_^3Í[è„h  ÉÂ ‹ÿU‹ìì$  ¡„@3Å‰Eü‹S‹]V‹p‰•àùÿÿ•ÜùÿÿRQ‹ÎÿÄTÿÖ‹ğ…öˆ  W‹½Üùÿÿ3öj jÿÿ4õ€ jÿWÿTƒøt
Fƒşrá3ÿë‹<õ„ …ÿ„·   h  …ìûÿÿPÿµàùÿÿÿ5ÈDÿ¸S‹ğ÷Şöæû¿ÿÆ@ €…À„   h  …ôıÿÿPWÿ5ÈDÿ¸S‹ğ¿û¿ÿ÷Şö#÷Æ@ €…Àt]…ôıÿÿ‰…àùÿÿ…àùÿÿPh  …äùÿÿPj j …ìûÿÿPh $  ÿàS‹ğ÷Şö#÷Æ@ €…Àtäùÿÿë¹D9 ‹Óè¼üÿÿ‹ğÿµÜùÿÿÿXS_‹Mü‹Æ^3Í[è$g  ÉÂ ‹ÿU‹ìƒì$¡„@3Å‰EüV3öMÜ¸D9 ‰uÜ‹Ğ‰uà‰uä‰uèèÑ¾ÿÿ‹ĞMäèÇ¾ÿÿ3ÀÇEğ   @ÇEø2   ‰Eì‰EôEÜPjh×  Vÿ¼T‹Mü3Í^è²f  ÉÂ ‹ÿU‹ìV‹uşşÿÿv	ºW €3ÀëCW‹}º	  +ù†÷şÿÿÂt·f…Àtf‰ƒÁƒêuâ_…Òuƒé3À÷ÚÒâ†ÿøÂz €f‰‹Â^]Â ÌÌÌÌÌÌÌ‹ÁÃÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìV‹ñè   öEt‹Îè°¿ÿÿ‹Æ^]Â ‹ÿV‹ñNÇ4 è¥½ÿÿNè½ÿÿ‹Nè†¿ÿÿÿvƒf ÿXSÇH ‹Î^ÿ%Q‹ÿU‹ìS‹]W‹ù…Ûu¸@ €ë^‹M‰OVQ‹‹p‹ÎÿÄTÿÖ‰_3Û9_u‹M‰OQ‹‹p‹ÎÿÄTÿÖW9u‹GRP‹‹q‹ÎÿÄTÿÖ‹ØÇG   ‹Ã^_[]Â ‹ÿU‹ìƒìSV‹ñ3ÛW¿@ €9^„ö   ‹V…Ò„ë   3ÉèZ4  …Àu,9^„×   ‹N…É„Ì   ‹V…Ò„Á   jSè§4  é´   ‹FUü‰]üRP‹‹q(‹ÎÿÄTÿÖ…Àˆ’   ‹Mü…É„‡   ‰]ôUô‹RQ‹p‹ÎÿÄTÿÖ‹ø‹E9EôrS‹MüUøR‰]øHP‹1Q‹NÿÄTÿV‹ø…ÿx2‹Mø…Ét+ÿu‹ÿuQ‹p‹ÎÿÄTÿÖ‹ø‹EøP‹‹q‹ÎÿÄTÿÖ‹EüP‹‹q‹ÎÿÄTÿÖ‹Ç_^[ÉÂ ‹ÿU‹ìQQS3ÛW¿@ €‰]ü9Y„   ‹I…É„“   ‹UüVRQ‹p‹ÎÿÄTÿÖ‹ø…ÿxw9]ütrh  Sÿ,SPÿ(S‹ØEøPh|K jj h S ÿTS…Àx1‹Müè³»ÿÿ‹EøÿuüP‹‹q‹ÎÿÄTÿÖ‹EøP‹‹q‹ÎÿÄTÿÖÿuüÿXSSÿ(S^‹Ç_[ÉÃ‹ÿU‹ìƒìS‹ÙVW3ö¿@ €‹K‰uøèK3  …Àt
‹E‰0é  ‹S3Éèv2  …Àu9u…ñ   ÿu‹KjZè§úÿÿ‹øéÜ   ‹CUü‰uüRP‹‹q(‹ÎÿÄTÿÖ…Àˆº   ‹Mü…É„¯   ƒeğ Uğ‹RQ‹p‹ÎÿÄTÿÖ‹M‹øA9Eğrw‹EüUôƒeô RQ‹0P‹NÿÄTÿV‹ø…ÿxV‹Mô…ÉtJ‹UøRQ‹p‹ÎÿÄTÿÖ‹ø…ÿx‹S‹Møj3ÿuèqùÿÿÿuø‹øÿXS‹EôP‹‹q‹ÎÿÄTÿÖë¿@ €‹EüP‹‹q‹ÎÿÄTÿÖ‹Ç_^[ÉÂ ‹ÿU‹ìƒìƒeğ S‹]V‹ñWƒ# ¿@ €‹Nè2  …À…ó   ‹V3Éè91  …À„á   ‹FUüƒeü RP‹‹q(‹ÎÿÄTÿÖ…Àˆ¾   ‹Mü…É„³   ƒeô Uô‹RQ‹p‹ÎÿÄTÿÖ‹U‹øJ9Môr{‹EüMøƒeø QR‹0P‹NÿÄTÿV…ÀxW‹Mø…ÉtP‹UğRQ‹p‹ÎÿÄTÿÖ‹ø…ÿxƒ}ğ u‹E…ÀtÆ  ‹Ó¹D9 èÉöÿÿ¿@ €‹EøP‹‹q‹ÎÿÄTÿÖë¿@ €‹EüP‹‹q‹ÎÿÄTÿÖ‹Ç_^[ÉÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìì   ¡„@3Å‰Eü‹E3ÒSV‹u‹Ù‰…ğıÿÿ‹EW‰¿@ €‰µàıÿÿ‰…ìıÿÿ‰•èıÿÿ9Su7jè1ºÿÿYj
Pj!ÿ5ÈD‰Cÿ¸S…Àu‹Kè)ºÿÿ3Ò‰Së3Ò‹…ìıÿÿ…Àtˆ‹K…É„  9S„  èÚöÿÿ…À…ú  h,J ÿµğıÿÿÿüR…Àu@‹C•èıÿÿRP‹‹q‹ÎÿÄTÿÖ‹ø…ÿˆÆ  ‹…àıÿÿ‹S‹èıÿÿj?Pèşöÿÿé‰  hDJ ÿµğıÿÿÿüR…À…²   ‹KèÔ/  …À…Ç   ‹S3Éè/  …Àuh  …ôıÿÿPjé´   ‹C•ìıÿÿ3É‰ìıÿÿR‹P‹q,‹ÎÿÄTÿÖ…Àˆ6  ‹…ìıÿÿ•èıÿÿRP‹‹q‹ÎÿÄTÿÖ…Àx%‹…àıÿÿ‹S‹èıÿÿjPèMöÿÿÿµèıÿÿ‹øÿXS‹…ìıÿÿP‹‹qéä  h\J ÿµğıÿÿÿüR…À…å   ‹Kè	/  …Àt6h  …ôıÿÿPjÿ5ÈDÿ¸S…À„˜  ‹Öôıÿÿè`ôÿÿ‹øé„  ‹S3Éè.  3É…Àu‰ém  ‹C•ìıÿÿ‰ìıÿÿRP‹‹q$‹ÎÿÄTÿÖ…ÀˆE  ‹ìıÿÿ…É„7  ‹•äıÿÿRQ‹p‹ÎÿÄTÿÖ…Àx(‹…àıÿÿ‹S‹äıÿÿhÿ   PèQõÿÿÿµäıÿÿ‹øÿXS‹ìıÿÿ3À‰…ìıÿÿéØ   h€J ÿµğıÿÿÿüR…À…å   ‹Kè.  …À…Ì   ‹S3Éè<-  …À„º   3À•ğıÿÿ‰…ğıÿÿ‹CRP‹‹q$‹ÎÿÄTÿÖ…Àˆ|  ‹ğıÿÿ…É„n  ‹•äıÿÿRQ‹p‹ÎÿÄTÿÖ…Àx<‹äıÿÿ…Ét+3Àf9t$‹•àıÿÿèóÿÿ‹ø‹…ìıÿÿ…Àt…ÿxÆ ‹äıÿÿQÿXS‹ğıÿÿ3À‰…ğıÿÿ…É„  ‹Q‹p‹ÎÿÄTÿÖéì  3À‰éã  h$7 ÿµğıÿÿÿüR…ÀuPé–   h”J ÿµğıÿÿÿüR…ÀuPéŸ   h<7 ÿµğıÿÿÿüR…Àujëbh´J ÿµğıÿÿÿüR…ÀujëmhT7 ÿµğıÿÿÿüR…Àujë0hÔJ ÿµğıÿÿÿüR…Àujë;hl7 ÿµğıÿÿÿüR…ÀujV‹ËèùÿÿéšıÿÿhôJ ÿµğıÿÿÿüR…Àujÿµìıÿÿ‹ËVèúÿÿépıÿÿh„7 ÿµğıÿÿÿüR…À…â   ‹C•èıÿÿRP‹‹q‹ÎÿÄTÿÖ‹ø…ÿˆ¡   ƒ½èıÿÿ „”   ‹Kèô+  …À…„   ‹S3Éè%+  …Àtv‹C•äıÿÿRP‹‹q‹ÎÿÄTÿÖ…Àx%‹äıÿÿ…Ét‹•àıÿÿè5ñÿÿÿµäıÿÿ‹øÿXSë=h  …ôıÿÿPjÿ5ÈDÿ¸S…Àt‹•àıÿÿôıÿÿèöğÿÿ‹øë
‹…àıÿÿ3É‰ÿµèıÿÿÿXSë¿ÿÿ €‹Mü‹Ç_^3Í[èK[  ÉÂ ÌÌÌÌÌÌÌ‹ÿU‹ìV‹ñè   öEt‹ÎèÀ´ÿÿ‹Æ^]Â ‹ÿU‹ìQSVW‹ù3ÛÇ w‹…Àt‹‹Ğë3É3Ò;Ù}'SRèûS  ‰Eü…Àt‹j‹1‹ÎÿÄT‹MüÿÖwCëÅ…ÀtPèT  ‹Îè2  ‹ÏÇ( ÿQ_^[ÉÃ‹ÿU‹ìQQS‹]‹ÁVWƒÏÿ‰Eüƒ# 3ö‹@…Àt‹ë3É;ñ}LVPè…S  ‰Eø‹H‹Ef‹f;uf…Òtf‹Pf;QuƒÀƒÁf…ÒuŞ3ÀëÀƒÈ…Àt‹EüFëª‹Eø‹ş‰‹Ç_^[ÉÂ ‹ÿU‹ìQSVW‹Ùj ‰]üè–³ÿÿ‹øY…ÿt'‹ÏÿQ3öÇ4 ‰w‰w‰w‰w‰w‰w‰wë3ö‹ş…ÿ„’   ÿu‹ÏÿuSèıóÿÿ‹Ø…Ûxj‹Eü9puj
èER  ‹Mü‰A…ÀuèO  ‹Ø‹Eüë‹Á…Ûx?WhÿÿÿÿpèŞR  ƒøÿt'€} ‹Şt=‹Eü‹H…Ét3‹@…Àt‹0FÿPWè´  ë» €‹j‹0‹ÎÿÄT‹ÏÿÖë» €_^‹Ã[ÉÂ ‹ÿU‹ì3À@9Eu
‹Mè2ïÿÿëƒ} u‹MèWïÿÿ]Â ‹ÿU‹ìƒìS‹]VW‹ùMü‹QS‹p‹ÎÿÄTÿÖ‹ğ…öˆ‹   ÿuÿuüèÿÿÿ…Àu|Eø‹ÏPÿuüèşÿÿ‰EôƒøÿtN‹MøƒÁè]°ÿÿSÿu‹]ø‹ËWèÕòÿÿ‹ğ…öx=‹…ÿt6è  ‹x@‹Môhøƒ  ‰H‹ÏP‰P‰Xÿ¸PëjSÿu‹Ïè:şÿÿ‹ğÿuüÿXS_‹Æ^[ÉÂ ‹ÿU‹ìƒì‹U‹Á‹MSVW3ÿ‰Eè‰:‹ß…É„I  ‹UğRQ‹p‹ÎÿÄTÿÖ‹Ø…Ûˆ6  ‹EğUô‰}ôRP‹‹q‹ÎÿÄTÿÖ‹Ø…Ûˆê   ‹Ï‰}ì9Mô†Ü   ‹EğUø‰}øRQ‹0P‹NÿÄTÿV‹Ø…Ûˆ¨   ‹EøUüRP‹‹q‹ÎÿÄTÿÖ‹Ø…Ûxx‹uè9~u#9}uWjÿhK jÿÿuüÿTƒè÷ØÀ@‰Fƒ}u
‹Müèíÿÿë9}u
‹Müè*íÿÿë‹Ç…Àtÿuÿuüèşÿÿ…ÀuWÿuø‹Îÿuèıÿÿ‹ØÿuüÿXS‹EøP‹‹q‹ÎÿÄTÿÖ‹MìA‰Mì;Mô‚$ÿÿÿ‹EğP‹‹q‹ÎÿÄTÿÖ…Ûx‹Eè‹U‹@…Àt‹8‰:_^‹Ã[ÉÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹A…Àt‹ Ã3ÀÃÌÌÌ‹ÿU‹ì‹I3À…Ét‹ë‹Ğ…Òt	ÿuQèœO  ]Â ‹ÿV‹ñƒ> tW3ÿWh Ø ÿ6è‹P  W‰>è6O  ‰>_^ÃÌÌÌÌ3À@Â ÿˆS…À~
·À  €…Àx¸@ €ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìV‹ñÇ( ÿQöEt‹Îè©¯ÿÿ‹Æ^]Â ÌÌÌÌÌÌÌÌ‹ÿU‹ìV‹ñÇH ÿQöEt‹Îèy¯ÿÿ‹Æ^]Â ÌÌÌÌÌÌÌÌ‹ÿU‹ì‹E‰A]Â Ì‹AÃ‹ÿU‹ìQQ…ÉttVEøPÿüP‹ğ…ötb‹W3ÿ÷ÁÿÿÿvKS÷Á   t‹FëF‹¸‹È‰Eüèr
  …Àt
ÿuPÿSÿu‹MüºÀÿ è›ÿÿÿ‹G‹Á%ÿÿÿ;ør·[‹MøÿR_^ÉÂ ‹ÿU‹ìQS‹]VWhœ   ƒ# ‹új‰Müÿ¤SPÿœS‹ğ…öt7‹Îÿ˜Pƒ¦˜    ‹ÎWÿuüÇ\ ÿôP‹ø…ÿx‰3ëj ‹ÎÿlQë¿ €‹Ç_^[ÉÂ ÌÌÌÌÌÌ¡ìDÃ‹ÿU‹ì‹M…Ét‹E…Àt‹I,H…Éuô…ÉtjıÿR]Â ‹ÿU‹ììT  ¡„@3Å‰EüS‹Ù‰Ğıÿÿƒ»    „$  ‹‹„   …É„  …¬ıÿÿPÿüP‰…°ıÿÿ…À„ï  ‹áÿÿÿj ‰´ıÿÿY‰Èıÿÿ†Ò  VPW÷    t‹ë‹Â‹4ˆ‰µÔıÿÿÿ¼P‹‹ø‹±Œ   ‹ÎÿÄT‹ÔıÿÿÿÖ;Ç…j  ‹Ôıÿÿ…ÄıÿÿPÿìPPÿ R‹Äıÿÿ·ğÿRV‹ËÿR‹ø‰½Üıÿÿ…ÿ„  ƒ»ˆ    „U  ‹Ôıÿÿ…ÀıÿÿPÿèP‹Àıÿÿ‹ØÿR…Û„Ğ  ‹½Ğıÿÿ…ãıÿÿƒ¥Øıÿÿ PÆ…ãıÿÿ …Øıÿÿ‹¿ˆ   PS‹7‹NÿÄT‹ÏÿV‹ø‰½Ìıÿÿ…ÿˆˆ  h¬6 SÿüR…ÀuA€½ãıÿÿ ‹…Ğıÿÿt
Ç€˜      ‹€ˆ   ‹µÜıÿÿ‹ÎÆ…ãıÿÿ ƒx( •À¶ÀPÿ$Rë‹µÜıÿÿ€½ãıÿÿ „
  ‹…Øıÿÿƒ¥Üıÿÿ fƒ8@u~h  äıÿÿQPÿôR…ÀtW…äıÿÿPÿS‹ø÷ß…ÿ~Jj"j …æıÿÿPÿÄS‰…¼ıÿÿ…Àt/ÜıÿÿQj ·ÏQPè‰J  ÿµ¼ıÿÿ‹ø‰½ÌıÿÿÿĞS‹…Üıÿÿë2‹½Ìıÿÿëğjjÿ4SPjÿ4SPjÿµØıÿÿj ÿ0S‰…Üıÿÿ…ÀtY3ÉQQQPÿ R‹ø…ÿtWjÿ5R‹ÎÿR‹ÏÿRëÿµÜıÿÿÿ€Rj ‹ÎÿR‹½ÌıÿÿëÿµØıÿÿ‹ÎÿRj‹ÎÿRë‹µÜıÿÿ‹Îj ÿRjı‹ÎÿR…ÿx(ƒ½Øıÿÿ „“   hD9 ÿµØıÿÿÿèR…À…  ëxh€J SÿèR…À„æ   h”J SÿèR…À„Ò   h´J SÿèR…À„¾   hÔJ SÿèR…À„ª   hôJ SÿèR…À„–   h K SÿèR…À„‚   h\J SÿèR…Àtnh„7 SÿèR…Àt^h<7 SÿèR…ÀtNhT7 SÿèR…Àt>hl7 SÿèR…Àt.h$7 SÿèR…Àu
jVè±ûÿÿë"h,J SÿèR…Àujëäjëàjı‹ÎÿRÿµØıÿÿÿ Ré¤   ‹µÔıÿÿ…¸ıÿÿP‹ÎÿüP‹Ø…ÛtB‹ÎÿäP#ÿÿÿ¿K‹÷Â   t‹	‹âÿÿÿRQ‹p@‹ÎÿÄT‹ÏÿÖ   @‹µÔıÿÿ‹R‹Îj jSÿøP‹ğ‹ÁáÁùƒùtƒùuVjS‹ÏÿR‹ÎÿR‹¸ıÿÿÿR‹Ğıÿÿ‹Ôıÿÿj ÿR‹ÔıÿÿjıÿR‹Èıÿÿ‹…°ıÿÿA‰ÈıÿÿP;´ıÿÿ‚5ûÿÿ_^‹¬ıÿÿÿR‹Mü3Í[è5O  ÉÃÌÌÌ¡ôDÃÌÌÌÌÌÌÌÌÌÌ‹ÿW‹ùƒ¿„    u
j3ÉÿlQ‹    …Ét‹VQ‹p‹ÎÿÄTÿÖƒ§     ^‹Ï_ÿ% Q‹ÿU‹ìS‹ÙVW‹}‹‰»˜   ‹°´   ‹ÎÿÄT‹ËÿÖ‰__^[]Â Ì‹ÿU‹ìSVW‹ùºÀÿ ‹Mÿ·    èb  ‹u‹‡„   ‹]‰ˆ   …Àt‰†„   ‹ÎèÛùÿÿ‹V‹p‹ÎÿÄT‹ËÿÖƒ}ÿ‹ÏujEPÿÀQëÿuÿuÿàP‹E3Û9˜˜   tAh¬6 ÿ R‹M·ÀPÿR‹ø…ÿt#‹‹±´   ‹ÎÿÄT‹ÏÿÖjSh  Pÿ8ShĞK ÿuÿèR…ÀuSëhäK ÿuÿèR…Àu
jÿuè:  _^[]Â ‹ÿU‹ìV‹ñè  ‹p@‹Îhøƒ  P‰P‹U‰P‹U‰Pÿ¸P^]Â ‹ÿU‹ìƒìƒeô EôSW‹ùP‰}ğÿ,REø‹ÏPÿÜPƒeü ‹ØEü3ÒP‹Ïèøÿÿ…Àx)‹‡Œ   V‹uü‹ÎS‰†Œ   ÿØPÿu‹ÏSVÿuèişÿÿ^ƒ}ô _[tÿuô‹Mğÿ0RÉÂ ‹ÿU‹ìQQƒeü EüVWP‰Møÿ,R‹}‹‹p‹ÎÿÄT‹ÏÿÖ‹ğ…ötj ºÀÿ ‹Îè  j ‹ÎÿlQ‹j‹0‹ÎÿÄT‹ÏÿÖƒ}ü _^tÿuü‹Møÿ0RÉÂ ‹ÿU‹ìƒìS‹]VW‹ù‹‹p‹ÎÿÄT‹ËÿÖ‹ğ…ö„”   ƒeğ EğP‹Ï‰}ìÿ,Rj ºÀÿ ‹Îè  jı‹ÎÿRj ‹ÎÿlQEô‹ÏPÿÜPƒeü 3Ò‰Eø‹ÏEüPèËöÿÿ…Àx)‹uü‹Î‹‡Œ   ÿuø‰†Œ   ÿØPÿu‹ÏÿuøVSè-ıÿÿƒ}ğ tÿuğ‹Mìÿ0R_^[ÉÂ ‹ÿU‹ìV‹ñè+  ‹l@‹Îhøƒ  Pƒ` ‰P‹U‰Pÿ¸P^]Â ‹ÿU‹ìQQ‹ÁMøSQ‹È‰EüÿüP‹Ø…Ût[‹EV‹3æÿÿÿƒøÿu‹Æ‰EW3ÿ…öt<K÷   t‹	‹Uü;ø