"use strict";
/**
 * This module defines nodes used to define types and validations for objects and interfaces.
 */
// tslint:disable:no-shadowed-variable prefer-for-of
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.basicTypes = exports.BasicType = exports.TParamList = exports.TParam = exports.param = exports.TFunc = exports.func = exports.TProp = exports.TOptional = exports.opt = exports.TIface = exports.iface = exports.TEnumLiteral = exports.enumlit = exports.TEnumType = exports.enumtype = exports.TIntersection = exports.intersection = exports.TUnion = exports.union = exports.TTuple = exports.tuple = exports.TArray = exports.array = exports.TLiteral = exports.lit = exports.TName = exports.name = exports.TType = void 0;
var util_1 = require("./util");
/** Node that represents a type. */
var TType = /** @class */ (function () {
    function TType() {
    }
    return TType;
}());
exports.TType = TType;
/** Parses a type spec into a TType node. */
function parseSpec(typeSpec) {
    return typeof typeSpec === "string" ? name(typeSpec) : typeSpec;
}
function getNamedType(suite, name) {
    var ttype = suite[name];
    if (!ttype) {
        throw new Error("Unknown type " + name);
    }
    return ttype;
}
/**
 * Defines a type name, either built-in, or defined in this suite. It can typically be included in
 * the specs as just a plain string.
 */
function name(value) { return new TName(value); }
exports.name = name;
var TName = /** @class */ (function (_super) {
    __extends(TName, _super);
    function TName(name) {
        var _this = _super.call(this) || this;
        _this.name = name;
        _this._failMsg = "is not a " + name;
        return _this;
    }
    TName.prototype.getChecker = function (suite, strict, allowedProps) {
        var _this = this;
        var ttype = getNamedType(suite, this.name);
        var checker = ttype.getChecker(suite, strict, allowedProps);
        if (ttype instanceof BasicType || ttype instanceof TName) {
            return checker;
        }
        // For complex types, add an additional "is not a <Type>" message on failure.
        return function (value, ctx) { return checker(value, ctx) ? true : ctx.fail(null, _this._failMsg, 0); };
    };
    return TName;
}(TType));
exports.TName = TName;
/**
 * Defines a literal value, e.g. lit('hello') or lit(123).
 */
function lit(value) { return new TLiteral(value); }
exports.lit = lit;
var TLiteral = /** @class */ (function (_super) {
    __extends(TLiteral, _super);
    function TLiteral(value) {
        var _this = _super.call(this) || this;
        _this.value = value;
        _this.name = JSON.stringify(value);
        _this._failMsg = "is not " + _this.name;
        return _this;
    }
    TLiteral.prototype.getChecker = function (suite, strict) {
        var _this = this;
        return function (value, ctx) { return (value === _this.value) ? true : ctx.fail(null, _this._failMsg, -1); };
    };
    return TLiteral;
}(TType));
exports.TLiteral = TLiteral;
/**
 * Defines an array type, e.g. array('number').
 */
function array(typeSpec) { return new TArray(parseSpec(typeSpec)); }
exports.array = array;
var TArray = /** @class */ (function (_super) {
    __extends(TArray, _super);
    function TArray(ttype) {
        var _this = _super.call(this) || this;
        _this.ttype = ttype;
        return _this;
    }
    TArray.prototype.getChecker = function (suite, strict) {
        var itemChecker = this.ttype.getChecker(suite, strict);
        return function (value, ctx) {
            if (!Array.isArray(value)) {
                return ctx.fail(null, "is not an array", 0);
            }
            for (var i = 0; i < value.length; i++) {
                var ok = itemChecker(value[i], ctx);
                if (!ok) {
                    return ctx.fail(i, null, 1);
                }
            }
            return true;
        };
    };
    return TArray;
}(TType));
exports.TArray = TArray;
/**
 * Defines a tuple type, e.g. tuple('string', 'number').
 */
function tuple() {
    var typeSpec = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        typeSpec[_i] = arguments[_i];
    }
    return new TTuple(typeSpec.map(function (t) { return parseSpec(t); }));
}
exports.tuple = tuple;
var TTuple = /** @class */ (function (_super) {
    __extends(TTuple, _super);
    function TTuple(ttypes) {
        var _this = _super.call(this) || this;
        _this.ttypes = ttypes;
        return _this;
    }
    TTuple.prototype.getChecker = function (suite, strict) {
        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict); });
        var checker = function (value, ctx) {
            if (!Array.isArray(value)) {
                return ctx.fail(null, "is not an array", 0);
            }
            for (var i = 0; i < itemCheckers.length; i++) {
                var ok = itemCheckers[i](value[i], ctx);
                if (!ok) {
                    return ctx.fail(i, null, 1);
                }
            }
            return true;
        };
        if (!strict) {
            return checker;
        }
        return function (value, ctx) {
            if (!checker(value, ctx)) {
                return false;
            }
            return value.length <= itemCheckers.length ? true :
                ctx.fail(itemCheckers.length, "is extraneous", 2);
        };
    };
    return TTuple;
}(TType));
exports.TTuple = TTuple;
/**
 * Defines a union type, e.g. union('number', 'null').
 */
function union() {
    var typeSpec = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        typeSpec[_i] = arguments[_i];
    }
    return new TUnion(typeSpec.map(function (t) { return parseSpec(t); }));
}
exports.union = union;
var TUnion = /** @class */ (function (_super) {
    __extends(TUnion, _super);
    function TUnion(ttypes) {
        var _this = _super.call(this) || this;
        _this.ttypes = ttypes;
        var names = ttypes.map(function (t) { return t instanceof TName || t instanceof TLiteral ? t.name : null; })
            .filter(function (n) { return n; });
        var otherTypes = ttypes.length - names.length;
        if (names.length) {
            if (otherTypes > 0) {
                names.push(otherTypes + " more");
            }
            _this._failMsg = "is none of " + names.join(", ");
        }
        else {
            _this._failMsg = "is none of " + otherTypes + " types";
        }
        return _this;
    }
    TUnion.prototype.getChecker = function (suite, strict) {
        var _this = this;
        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict); });
        return function (value, ctx) {
            var ur = ctx.unionResolver();
            for (var i = 0; i < itemCheckers.length; i++) {
                var ok = itemCheckers[i](value, ur.createContext());
                if (ok) {
                    return true;
                }
            }
            ctx.resolveUnion(ur);
            return ctx.fail(null, _this._failMsg, 0);
        };
    };
    return TUnion;
}(TType));
exports.TUnion = TUnion;
/**
 * Defines an intersection type, e.g. intersection('number', 'null').
 */
function intersection() {
    var typeSpec = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        typeSpec[_i] = arguments[_i];
    }
    return new TIntersection(typeSpec.map(function (t) { return parseSpec(t); }));
}
exports.intersection = intersection;
var TIntersection = /** @class */ (function (_super) {
    __extends(TIntersection, _super);
    function TIntersection(tt–D  VD  6D  DD  ‰D  íD  ∆D  *D      ˆD      «UnhandledExceptionFilter  áSetUnhandledExceptionFilter $GetCurrentProcess ¶TerminateProcess  õIsProcessorFeaturePresent aQueryPerformanceCounter %GetCurrentProcessId )GetCurrentThreadId  ˙GetSystemTimeAsFileTime xInitializeSListHead îIsDebuggerPresent ÅInterlockedFlushSList ÈRtlUnwind nGetLastError  HSetLastError  DeleteCriticalSection tInitializeCriticalSectionAndSpinCount ∏TlsAlloc  ∫TlsGetValue ªTlsSetValue πTlsFree ∑FreeLibrary ΩGetProcAddress  ŸLoadLibraryExW  KERNEL32.dll  8 _initterm 9 _initterm_e A _seh_filter_dll  _configure_narrow_argv  5 _initialize_narrow_environment  6 _initialize_onexit_table  $ _execute_onexit_table  _cexit  j terminate  free  W abort  calloc  ¶ wcsncmp api-ms-win-crt-runtime-l1-1-0.dll api-ms-win-crt-heap-l1-1-0.dll  api-ms-win-crt-string-l1-1-0.dll                                                                                                                                                              ±øDNÊ@ªˇˇˇˇ                   ˇˇˇˇ             ì            uò                                                                                                                                                                                                                                                                                                                                                                                                                                                                           0 Ä0  Ä   H  Ä   `  Ä   x  Ä                  ê  Ä                  ®  Ä                  ¿  Ä                  ÿ  Ä               	                    	                    	                   	     s  
"          ‡e            Pa  å           ñ  ë            W E V T _ T E M P L A T E     å4   V S _ V E R S I O N _ I N F O     ΩÔ˛               ?                        Ï   S t r i n g F i l e I n f o   »   0 4 0 9 0 4 b 0   L   C o m p a n y N a m e     M i c r o s o f t   C o r p o r a t i o n   ¿ L  F i l e D e s c r i p t i o n     W i n d o w s A p p S d k . A p p x D e p l o y m e n t E x t e n s i o n s . D e s k t o p - E v e n t L o g - I n s t r u m e n t a t i o n . d l l   (   F i l e V e r s i o n     1 . 4   ∏ L  I n t e r n a l N a m e   W i n d o w s A p p S d k . A p p x D e p l o y m e n t E x t e n s i o n s . D e s k t o p - E v e n t L o g - I n s t r u m e n t a t i o n . d l l   ò :  L e g a l C o p y r i g h t   C o p y r i g h t   ( c )   M i c r o s o f t   C o r p o r a t i o n .   A l l   r i g h t s   r e s e r v e d .   ¿ L  O r i g i n a l F i l e n a m e   W i n d o w s A p p S d k . A p p x D e p l o y m e n t E x t e n s i o n s . D e s k t o p - E v e n t L o g - I n s t r u m e n t a t i o n . d l l   @   P r o d u c t N a m e     W i n d o w s   A p p   S D K   ,   P r o d u c t V e r s i o n   1 . 4   D    V a r F i l e I n f o     $    T r a n s l a t i o n     	∞         P  PL     P  P`     ê  êò   (# ∞-# ∞\  ' ∞' ∞»    –  –à    E r r o r  
      I n f o r m a t i o n  
     V e r b o s e  
   p  M i c r o s o f t - W i n d o w s - A p p X D e p l o y m e n t - S e r v e r - U n d o c k e d D e h  
   T  A p p x D e p l o y m e n t U n d o c k e d D e h / O p e r a t i o n a l  
   ∏  I n s t a l l i n g   E v e n t L o g   m a n i f e s t   f o r   p a c k a g e :   ' % 1 '   ( S e e   ' D e t a i l s '   f o r   e x t e n d e d   i n f o r m a t i o n )  
   º  U n i n s t a l l i n g   E v e n t L o g   m a n i f e s t   f o r   p a c k a g e :   ' % 1 '   ( S e e   ' D e t a i l s '   f o r   e x t e n d e d   i n f o r m a t i o n )  
   ∏  I n s t a l l e d   E v e n t L o g   m a n i f e s t   f o r   p a c k a g e :   ' % 1 '   ( S e e   ' D e t a i l s '   f o r   e x t e n d e d   i n f o r m a t i o n )  
     º  U n i n s t a l l e d   E v e n t L o g   m a n i f e s t   f o r   p a c k a g e :   ' % 1 '   ( S e e   ' D e t a i l s '   f o r   e x t e n d e d   i n f o r m a t i o n )  
     ¿  S e t t i n g   a c t i v e   E v e n t L o g   m a n i f e s t   f o r   p a c k a g e :   ' % 1 '   ( S e e   ' D e t a i l s '   f o r   e x t e n d e d   i n f o r m a t i o n )  
   ƒ  U n s e t t i n g   a c t i v e   E v e n t L o g   m a n i f e s t   f o r   p a c k a g e :   ' % 1 '   ( S e e   ' D e t a i l s '   f o r   e x t e n d e d   i n f o r m a t i o n )  
   ú  L o a d i n g   r e g i s t r a t i o n   t a b l e   f o r   U n d o c k e d   D E H   d l l :   % 1 ,   P a t h :   % 2 ,   P h a s e :   % 3  
     p  E v a l u a t i n g   r e q u e s t   f o r   D E H :   D E H   ' % 1 '   i n   P h a s e   ' % 2 '  
     8  S t r i n g A d d E n t r y E v e n t :   % 1  
     F a i l e d   p e r f o r m i n g   D E H   r e q u e s t :   A c t i o n   ' % 1 '   i n   D E H   ' % 2 '   i n   P h a s e   ' % 3 '   i n   S t a t e   ' % 4 '   ( S e e   ' D e t a i l s '   f o r   e x t e n d e d   i n f o r m a t i o n )  
   ‡  F a i l e d   p e r f o r m i n g   o p e r a t i o n   o n   e n t r y :   O p e r a t i o n   ' % 1 '   o n   E n t r y   ' % 2 '   ( S e e   ' D e t a i l s '   f o r   e x t e n d e d   i n f o r m a t i o n )  
   l E n c o u n t e r e d   p a c k a g e   p a i r   i n   D E H   p a c k a g e   e v a l u a t i o n :   D E H   ' % 1 '   i n   P h a s e   ' % 2 '   S t a t e   ' % 3 '   o n   I n c o m i n g   P a c k a g e   ' % 4 '   a n d   O u t g o i n g   P a c k a g e   ' % 5 '   ( S e e   ' D e t a i l s '   f o r   e x t e n d e d   i n f o r m a t i o n )  
   ` E n c o u n t e r e d   p a c k a g e   i n   D E H   p a c k a g e   e v a l u a t i o n :   D i r e c t i o n   ' % 1 ' ,   D E H   ' % 2 ' ,   P a c k a g e   ' % 3 ' ,   P o s t O s U p g r a d e   ' % 4 ' ,   P h a s e   ' % 5 ' ,   S t a t e   ' % 6 '   ( S e e   ' D e t a i l s '   f o r   e x t e n d e d   i n f o r m a t i o n )  
     ¥  F a i l u r e   w o r k i n g   o n   i t e m s :   I t e m   c o u n t   ' % 1 ' ,   C u r r e n t   i t e m   n a m e   ' % 2 ' ,   S t e p   c o u n t e r   ' % 3 '  
     t  F a i l u r e   w o r k i n g   o n   i t e m :   I t e m   ' % 1 ' ,   S t e p   c o u n t e r   ' % 2 '  
   ®  F a i l u r e   a t   f r a m e :   F i l e   ' % 1 ' ,   L i n e   ' % 2 '   ( S e e   ' D e t a i l s '   f o r   e x t e n d e d   i n f o r m a t i o n )  
     P e r U s e r  
      P e r M a c h i n e  
       S i n g l e t o n  
     S y s t e m  
       O n e T i m e  
       CRIM"       >ÉCç}MäØÆåÖ Òå$   WEVT‰!    ê	      |           t     h     ‰           |     Ë     ¯  CHANà          ò        êl   M i c r o s o f t - W i n d o w s - A p p X D e p l o y m e n t - S e r v e r / O p e r a t i o n a l   MAPSp        VMAP<   P               –     –     –     –     –$   D e h P h a s e E n u m M a p   TTBLÙ     TEMPt        x     ãçÎ]¨±S≠ÕìÕZè ˇˇƒ   DÇ	 E v e n t D a t a   AˇˇI   äo D a t a   1   Kï N a m e    P a c k a g e F u l l N a m e   AˇˇS   äo D a t a   ;   Kï N a m e    U n d o c k e d D e h D l l P a r e n t                 †                ƒ  $   P a c k a g e F u l l N a m e   0   U n d o c k e d D e h D l l P a r e n t     TEMPt        Ï     ãçÎ]¨±S≠ÕìÕZè ˇˇƒ   DÇ	 E v e n t D a t a   AˇˇI   äo D a t a   1   Kï N a m e    P a c k a g e F u l l N a m e   AˇˇS   äo D a t a   ;   Kï N a m e    U n d o c k e d D e h D l l P a r e n t                                 8  $   P a c k a g e F u l l N a m e   0   U n d o c k e d D e h D l l P a r e n t     TEMPt        `     ãçÎ]¨±S≠ÕìÕZè ˇˇƒ   DÇ	 E v e n t D a t a   AˇˇI   äo D a t a   1   Kï N a m e    P a c k a g e F u l l N a m e   AˇˇS   äo D a t a   ;   Kï N a m e    U n d o c k e d D e h D l l P a r e n t                 à                ¨  $   P a c k a g e F u l l N a m e   0   U n d o c k e d D e h D l l P a r e n t     TEMPt        ‘     ãçÎ]¨±S≠ÕìÕZè ˇˇƒ   Daram = TParam;
/**
 * Defines a function parameter list.
 */
var TParamList = /** @class */ (function (_super) {
    __extends(TParamList, _super);
    function TParamList(params) {
        var _this = _super.call(this) || this;
        _this.params = params;
        return _this;
    }
    TParamList.prototype.getChecker = function (suite, strict) {
        var _this = this;
        var itemCheckers = this.params.map(function (t) { return t.ttype.getChecker(suite, strict); });
        var testCtx = new util_1.NoopContext();
        var isParamRequired = this.params.map(function (param, i) {
            return !param.isOpt && !itemCheckers[i](undefined, testCtx);
        });
        var checker = function (value, ctx) {
            if (!Array.isArray(value)) {
                return ctx.fail(null, "is not an array", 0);
            }
            for (var i = 0; i < itemCheckers.length; i++) {
                var p = _this.params[i];
                if (value[i] === undefined) {
                    if (isParamRequired[i]) {
                        return ctx.fail(p.name, "is missing", 1);
                    }
                }
                else {
                    var ok = itemCheckers[i](value[i], ctx);
                    if (!ok) {
                        return ctx.fail(p.name, null, 1);
                    }
                }
            }
            return true;
        };
        if (!strict) {
            return checker;
        }
        return function (value, ctx) {
            if (!checker(value, ctx)) {
                return false;
            }
            return value.length <= itemCheckers.length ? true :
                ctx.fail(itemCheckers.length, "is extraneous", 2);
        };
    };
    return TParamList;
}(TType));
exports.TParamList = TParamList;
/**
 * Single TType implementation for all basic built-in types.
 */
var BasicType = /** @class */ (function (_super) {
    __extends(BasicType, _super);
    function BasicType(validator, message) {
        var _this = _super.call(this) || this;
        _this.validator = validator;
        _this.message = message;
        return _this;
    }
    BasicType.prototype.getChecker = function (suite, strict) {
        var _this = this;
        return function (value, ctx) { return _this.validator(value) ? true : ctx.fail(null, _this.message, 0); };
    };
    return BasicType;
}(TType));
exports.BasicType = BasicType;
/**
 * Defines the suite of basic types.
 */
exports.basicTypes = {
    any: new BasicType(function (v) { return true; }, "is invalid"),
    number: new BasicType(function (v) { return (typeof v === "number"); }, "is not a number"),
    object: new BasicType(function (v) { return (typeof v === "object" && v); }, "is not an object"),
    boolean: new BasicType(function (v) { return (typeof v === "boolean"); }, "is not a boolean"),
    string: new BasicType(function (v) { return (typeof v === "string"); }, "is not a string"),
    symbol: new BasicType(function (v) { return (typeof v === "symbol"); }, "is not a symbol"),
    void: new BasicType(function (v) { return (v == null); }, "is not void"),
    undefined: new BasicType(function (v) { return (v === undefined); }, "is not undefined"),
    null: new BasicType(function (v) { return (v === null); }, "is not null"),
    never: new BasicType(function (v) { return false; }, "is unexpected"),
    Date: new BasicType(getIsNativeChecker("[object Date]"), "is not a Date"),
    RegExp: new BasicType(getIsNativeChecker("[object RegExp]"), "is not a RegExp"),
};
// This approach for checking native object types mirrors that of lodash. Its advantage over
// `isinstance` is that it can still return true for native objects created in different JS
// execution environments.
var nativeToString = Object.prototype.toString;
function getIsNativeChecker(tag) {
    return function (v) { return typeof v === "object" && v && nativeToString.call(v) === tag; };
}
if (typeof Buffer !== "undefined") {
    exports.basicTypes.Buffer = new BasicType(function (v) { return Buffer.isBuffer(v); }, "is not a Buffer");
}
var _loop_1 = function (array_1) {
    exports.basicTypes[array_1.name] = new BasicType(function (v) { return (v instanceof array_1); }, "is not a " + array_1.name);
};
// Support typed arrays of various flavors
for (var _i = 0, _a = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,
    Int32Array, Uint32Array, Float32Array, Float64Array, ArrayBuffer]; _i < _a.length; _i++) {
    var array_1 = _a[_i];
    _loop_1(array_1);
}
