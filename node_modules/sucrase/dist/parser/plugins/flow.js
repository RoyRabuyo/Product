"use strict";Object.defineProperty(exports, "__esModule", {value: true});/* eslint max-len: 0 */










var _index = require('../tokenizer/index');
var _keywords = require('../tokenizer/keywords');
var _types = require('../tokenizer/types');
var _base = require('../traverser/base');













var _expression = require('../traverser/expression');








var _statement = require('../traverser/statement');









var _util = require('../traverser/util');

function isMaybeDefaultImport(lookahead) {
  return (
    (lookahead.type === _types.TokenType.name || !!(lookahead.type & _types.TokenType.IS_KEYWORD)) &&
    lookahead.contextualKeyword !== _keywords.ContextualKeyword._from
  );
}

function flowParseTypeInitialiser(tok) {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _util.expect.call(void 0, tok || _types.TokenType.colon);
  flowParseType();
  _index.popTypeContext.call(void 0, oldIsType);
}

function flowParsePredicate() {
  _util.expect.call(void 0, _types.TokenType.modulo);
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._checks);
  if (_index.eat.call(void 0, _types.TokenType.parenL)) {
    _expression.parseExpression.call(void 0, );
    _util.expect.call(void 0, _types.TokenType.parenR);
  }
}

function flowParseTypeAndPredicateInitialiser() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _util.expect.call(void 0, _types.TokenType.colon);
  if (_index.match.call(void 0, _types.TokenType.modulo)) {
    flowParsePredicate();
  } else {
    flowParseType();
    if (_index.match.call(void 0, _types.TokenType.modulo)) {
      flowParsePredicate();
    }
  }
  _index.popTypeContext.call(void 0, oldIsType);
}

function flowParseDeclareClass() {
  _index.next.call(void 0, );
  flowParseInterfaceish(/* isClass */ true);
}

function flowParseDeclareFunction() {
  _index.next.call(void 0, );
  _expression.parseIdentifier.call(void 0, );

  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  _util.expect.call(void 0, _types.TokenType.parenL);
  flowParseFunctionTypeParams();
  _util.expect.call(void 0, _types.TokenType.parenR);

  flowParseTypeAndPredicateInitialiser();

  _util.semicolon.call(void 0, );
}

function flowParseDeclare() {
  if (_index.match.call(void 0, _types.TokenType._class)) {
    flowParseDeclareClass();
  } else if (_index.match.call(void 0, _types.TokenType._function)) {
    flowParseDeclareFunction();
  } else if (_index.match.call(void 0, _types.TokenType._var)) {
    flowParseDeclareVariable();
  } else if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._module)) {
    if (_index.eat.call(void 0, _types.TokenType.dot)) {
      flowParseDeclareModuleExports();
    } else {
      flowParseDeclareModule();
    }
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._type)) {
    flowParseDeclareTypeAlias();
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque)) {
    flowParseDeclareOpaqueType();
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._interface)) {
    flowParseDeclareInterface();
  } else if (_index.match.call(void 0, _types.TokenType._export)) {
    flowParseDeclareExportDeclaration();
  } else {
    _util.unexpected.call(void 0, );
  }
}

function flowParseDeclareVariable() {
  _index.next.call(void 0, );
  flowParseTypeAnnotatableIdentifier();
  _util.semicolon.call(void 0, );
}

function flowParseDeclareModule() {
  if (_index.match.call(void 0, _types.TokenType.string)) {
    _expression.parseExprAtom.call(void 0, );
  } else {
    _expression.parseIdentifier.call(void 0, );
  }

  _util.expect.call(void 0, _types.TokenType.braceL);
  while (!_index.match.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
    if (_index.match.call(void 0, _types.TokenType._import)) {
      _index.next.call(void 0, );
      _statement.parseImport.call(void 0, );
    } else {
      _util.unexpected.call(void 0, );
    }
  }
  _util.expect.call(void 0, _types.TokenType.braceR);
}

function flowParseDeclareExportDeclaration() {
  _util.expect.call(void 0, _types.TokenType._export);

  if (_index.eat.call(void 0, _types.TokenType._default)) {
    if (_index.match.call(void 0, _types.TokenType._function) || _index.match.call(void 0, _types.TokenType._class)) {
      // declare export default class ...
      // declare export default function ...
      flowParseDeclare();
    } else {
      // declare export default [type];
      flowParseType();
      _util.semicolon.call(void 0, );
    }
  } else if (
    _index.match.call(void 0, _types.TokenType._var) || // declare export var ...
    _index.match.call(void 0, _types.TokenType._function) || // declare export function ...
    _index.match.call(void 0, _types.TokenType._class) || // declare export class ...
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque) // declare export opaque ..
  ) {
    flowParseDeclare();
  } else if (
    _index.match.call(void 0, _types.TokenType.star) || // declare export * from ''
    _index.match.call(void 0, _types.TokenType.braceL) || // declare export {} ...
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._interface) || // declare export interface ...
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._type) || // declare export type ...
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque) // declare export opaque type ...
  ) {
    _statement.parseExport.call(void 0, );
  } else {
    _util.unexpected.call(void 0, );
  }
}

function flowParseDeclareModuleExports() {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._exports);
  flowParseTypeAnnotation();
  _util.semicolon.call(void 0, );
}

function flowParseDeclareTypeAlias() {
  _index.next.call(void 0, );
  flowParseTypeAlias();
}

function flowParseDeclareOpaqueType() {
  _index.next.call(void 0, );
  flowParseOpaqueType(true);
}

function flowParseDeclareInterface() {
  _index.next.call(void 0, );
  flowParseInterfaceish();
}

// Interfaces

function flowParseInterfaceish(isClass = false) {
  flowParseRestrictedIdentifier();

  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  if (_index.eat.call(void 0, _types.TokenType._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (!isClass && _index.eat.call(void 0, _types.TokenType.comma));
  }

  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._mixins)) {
    _index.next.call(void 0, );
    do {
      flowParseInterfaceExtends();
    } while (_index.eat.call(void 0, _types.TokenType.comma));
  }

  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._implements)) {
    _index.next.call(void 0, );
    do {
      flowParseInterfaceExtends();
    } while (_index.eat.call(void 0, _types.TokenType.comma));
  }

  flowParseObjectType(isClass, false, isClass);
}

function flowParseInterfaceExtends() {
  flowParseQualifiedTypeIdentifier(false);
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}

function flowParseInterface() {
  flowParseInterfaceish();
}

function flowParseRestrictedIdentifier() {
  _expression.parseIdentifier.call(void 0, );
}

function flowParseTypeAlias() {
  flowParseRestrictedIdentifier();

  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  flowParseTypeInitialiser(_types.TokenType.eq);
  _util.semicolon.call(void 0, );
}

function flowParseOpaqueType(declare) {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._type);
  flowParseRestrictedIdentifier();

  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  // Parse the supertype
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    flowParseTypeInitialiser(_types.TokenType.colon);
  }

  if (!declare) {
    flowParseTypeInitialiser(_types.TokenType.eq);
  }
  _util.semicolon.call(void 0, );
}

function flowParseTypeParameter() {
  flowParseVariance();
  flowParseTypeAnnotatableIdentifier();

  if (_index.eat.call(void 0, _types.TokenType.eq)) {
    flowParseType();
  }
}

 function flowParseTypeParameterDeclaration() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  // istanbul ignore else: this condition is already checked at all call sites
  if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.typeParameterStart)) {
    _index.next.call(void 0, );
  } else {
    _util.unexpected.call(void 0, );
  }

  do {
    flowParseTypeParameter();
    if (!_index.match.call(void 0, _types.TokenType.greaterThan)) {
      _util.expect.call(void 0, _types.TokenType.comma);
    }
  } while (!_index.match.call(void 0, _types.TokenType.greaterThan) && !_base.state.error);
  _util.expect.call(void 0, _types.TokenType.greaterThan);
  _index.popTypeContext.call(void 0, oldIsType);
} exports.flowParseTypeParameterDeclaration = flowParseTypeParameterDeclaration;

function flowParseTypeParameterInstantiation() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _util.expect.call(void 0, _types.TokenType.lessThan);
  while (!_index.match.call(void 0, _types.TokenType.greaterThan) && !_base.state.error) {
    flowParseType();
    if (!_index.match.call(void 0, _types.TokenType.greaterThan)) {
      _util.expect.call(void 0, _types.TokenType.comma);
    }
  }
  _util.expect.call(void 0, _types.TokenType.greaterThan);
  _index.popTypeContext.call(void 0, oldIsType);
}

function flowParseInterfaceType() {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._interface);
  if (_index.eat.call(void 0, _types.TokenType._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (_index.eat.call(void 0, _types.TokenType.comma));
  }
  flowParseObjectType(false, false, false);
}

function flowParseObjectPropertyKey() {
  if (_index.match.call(void 0, _types.TokenType.num) || _index.match.call(void 0, _types.TokenType.string)) {
    _expression.parseExprAtom.call(void 0, );
  } else {
    _expression.parseIdentifier.call(void 0, );
  }
}

function flowParseObjectTypeIndexer() {
  // Note: bracketL has already been consumed
  if (_index.lookaheadType.call(void 0, ) === _types.TokenType.colon) {
    flowParseObjectPropertyKey();
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
  _util.expect.call(void 0, _types.TokenType.bracketR);
  flowParseTypeInitialiser();
}

function flowParseObjectTypeInternalSlot() {
  // Note: both bracketL have already been consumed
  flowParseObjectPropertyKey();
  _util.expect.call(void 0, _types.TokenType.bracketR);
  _util.expect.call(void 0, _types.TokenType.bracketR);
  if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.parenL)) {
    flowParseObjectTypeMethodish();
  } else {
    _index.eat.call(void 0, _types.TokenType.question);
    flowParseTypeInitialiser();
  }
}

function flowParseObjectTypeMethodish() {
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  _util.expect.call(void 0, _types.TokenType.parenL);
  while (!_index.match.call(void 0, _types.TokenType.parenR) && !_index.match.call(void 0, _types.TokenType.ellipsis) && !_base.state.error) {
    flowParseFunctionTypeParam();
    if (!_index.match.call(void 0, _types.TokenType.parenR)) {
      _util.expect.call(void 0, _types.TokenType.comma);
    }
  }

  if (_index.eat.call(void 0, _types.TokenType.ellipsis)) {
    flowParseFunctionTypeParam();
  }
  _util.expect.call(void 0, _types.TokenType.parenR);
  flowParseTypeInitialiser();
}

function flowParseObjectTypeCallProperty() {
  flowParseObjectTypeMethodish();
}

function flowParseObjectType(allowStatic, allowExact, allowProto) {
  let endDelim;
  if (allowExact && _index.match.call(void 0, _types.TokenType.braceBarL)) {
    _util.expect.call(void 0, _types.TokenType.braceBarL);
    endDelim = _types.TokenType.braceBarR;
  } else {
    _util.expect.call(void 0, _types.TokenType.braceL);
    endDelim = _types.TokenType.braceR;
  }

  while (!_index.match.call(void 0, endDelim) && !_base.state.error) {
    if (allowProto && _util.isContextual.call(void 0, _keywords.ContextualKeyword._proto)) {
      const lookahead = _index.lookaheadType.call(void 0, );
      if (lookahead !== _types.TokenType.colon && lookahead !== _types.TokenType.question) {
        _index.next.call(void 0, );
        allowStatic = false;
      }
    }
    if (allowStatic && _util.isContextual.call(void 0, _keywords.ContextualKeyword._static)) {
      const lookahead = _index.lookaheadType.call(void 0, );
      if (lookahead !== _types.TokenType.colon && lookahead !== _types.TokenType.question) {
        _index.next.call(void 0, );
      }
    }

    flowParseVariance();

    if (_index.eat.call(void 0, _types.TokenType.bracketL)) {
      if (_index.eat.call(void 0, _types.TokenType.bracketL)) {
        flowParseObjectTypeInternalSlot();
      } else {
        flowParseObjectTypeIndexer();
      }
    } else if (_index.match.call(void 0, _types.TokenType.parenL) || _index.match.call(void 0, _types.TokenType.lessThan)) {
      flowParseObjectTypeCallProperty();
    } else {
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._get) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._set)) {
        const lookahead = _index.lookaheadType.call(void 0, );
        if (lookahead === _types.TokenType.name || lookahead === _types.TokenType.string || lookahead === _types.TokenType.num) {
          _index.next.call(void 0, );
        }
      }

      flowParseObjectTypeProperty();
    }

    flowObjectTypeSemicolon();
  }

  _util.expect.call(void 0, endDelim);
}

function flowParseObjectTypeProperty() {
  if (_index.match.call(void 0, _types.TokenType.ellipsis)) {
    _util.expect.call(void 0, _types.TokenType.ellipsis);
    if (!_index.eat.call(void 0, _types.TokenType.comma)) {
      _index.eat.call(void 0, _types.TokenType.semi);
    }
    // Explicit inexact object syntax.
    if (_index.match.call(void 0, _types.TokenType.braceR)) {
      return;
    }
    flowParseType();
  } else {
    flowParseObjectPropertyKey();
    if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.parenL)) {
      // This is a method property
      flowParseObjectTypeMethodish();
    } else {
      _index.eat.call(void 0, _types.TokenType.question);
      flowParseTypeInitialiser();
    }
  }
}

function flowObjectTypeSemicolon() {
  if (!_index.eat.call(void 0, _types.TokenType.semi) && !_index.eat.call(void 0, _types.TokenType.comma) && !_index.match.call(void 0, _types.TokenType.braceR) && !_index.match.call(void 0, _types.TokenType.braceBarR)) {
    _util.unexpected.call(void 0, );
  }
}

function flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {
  if (!initialIdAlreadyParsed) {
    _expression.parseIdentifier.call(void 0, );
  }
  while (_index.eat.call(void 0, _types.TokenType.dot)) {
    _expression.parseIdentifier.call(void 0, );
  }
}

function flowParseGenericType() {
  flowParseQualifiedTypeIdentifier(true);
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}

function flowParseTypeofType() {
  _util.expect.call(void 0, _types.TokenType._typeof);
  flowParsePrimaryType();
}

function flowParseTupleType() {
  _util.expect.call(void 0, _types.TokenType.bracketL);
  // We allow trailing commas
  while (_base.state.pos < _base.input.length && !_index.match.call(void 0, _types.TokenType.bracketR)) {
    flowParseType();
    if (_index.match.call(void 0, _types.TokenType.bracketR)) {
      break;
    }
    _util.expect.call(void 0, _types.TokenType.comma);
  }
  _util.expect.call(void 0, _types.TokenType.bracketR);
}

function flowParseFunctionTypeParam() {
  const lookahead = _index.lookaheadType.call(void 0, );
  if (lookahead === _types.TokenType.colon || lookahead === _types.TokenType.question) {
    _expression.parseIdentifier.call(void 0, );
    _index.eat.call(void 0, _types.TokenType.question);
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
}

function flowParseFunctionTypeParams() {
  while (!_index.match.call(void 0, _types.TokenType.parenR) && !_index.match.call(void 0, _types.TokenType.ellipsis) && !_base.state.error) {
    flowParseFunctionTypeParam();
    if (!_index.match.call(void 0, _types.TokenType.parenR)) {
      _util.expect.call(void 0, _types.TokenType.comma);
    }
  }
  if (_index.eat.call(void 0, _types.TokenType.ellipsis)) {
    flowParseFunctionTypeParam();
  }
}

// The parsing of types roughly parallels the parsing of expressions, and
// primary types are kind of like primary expressions...they're the
// primitives with which other types are constructed.
function flowParsePrimaryType() {
  let isGroupedType = false;
  const oldNoAnonFunctionType = _base.state.noAnonFunctionType;

  switch (_base.state.type) {
    case _types.TokenType.name: {
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._interface)) {
        flowParseInterfaceType();
        return;
      }
      _expression.parseIdentifier.call(void 0, );
      flowParseGenericType();
      return;
    }

    case _types.TokenType.braceL:
      flowParseObjectType(false, false, false);
      return;

    case _types.TokenType.braceBarL:
      flowParseObjectType(false, true, false);
      return;

    case _types.TokenType.bracketL:
      flowParseTupleType();
      return;

    case _types.TokenType.lessThan:
      flowParseTypeParameterDeclaration();
      _util.expect.call(void 0, _types.TokenType.parenL);
      flowParseFunctionTypeParams();
      _util.expect.call(void 0, _types.TokenType.parenR);
      _util.expect.call(void 0, _types.TokenType.arrow);
      flowParseType();
      return;

    case _types.TokenType.parenL:
      _index.next.call(void 0, );

      // Check to see if this is actually a grouped type
      if (!_index.match.call(void 0, _types.TokenType.parenR) && !_index.match.call(void 0, _types.TokenType.ellipsis)) {
        if (_index.match.call(void 0, _types.TokenType.name)) {
          const token = _index.lookaheadType.call(void 0, );
          isGroupedType = token !== _types.TokenType.question && token !== _types.TokenType.colon;
        } else {
          isGroupedType = true;
        }
      }

      if (isGroupedType) {
        _base.state.noAnonFunctionType = false;
        flowParseType();
        _base.state.noAnonFunctionType = oldNoAnonFunctionType;

        // A `,` or a `) =>` means this is an anonymous function type
        if (
          _base.state.noAnonFunctionType ||
          !(_index.match.call(void 0, _types.TokenType.comma) || (_index.match.call(void 0, _types.TokenType.parenR) && _index.lookaheadType.call(void 0, ) === _types.TokenType.arrow))
        ) {
          _util.expect.call(void 0, _types.TokenType.parenR);
          return;
        } else {
          // Eat a comma if there is one
          _index.eat.call(void 0, _types.TokenType.comma);
        }
      }

      flowParseFunctionTypeParams();

      _util.expect.call(void 0, _types.TokenType.parenR);
      _util.expect.call(void 0, _types.TokenType.arrow);
      flowParseType();
      return;

    case _types.TokenType.minus:
      _index.next.call(void 0, );
      _expression.parseLiteral.call(void 0, );
      return;

    case _types.TokenType.string:
    case _types.TokenType.num:
    case _types.TokenType._true:
    case _types.TokenType._false:
    case _types.TokenType._null:
    case _types.TokenType._this:
    case _types.TokenType._void:
    case _types.TokenType.star:
      _index.next.call(void 0, );
      return;

    default:
      if (_base.state.type === _types.TokenType._typeof) {
        flowParseTypeofType();
        return;
      } else if (_base.state.type & _types.TokenType.IS_KEYWORD) {
        _index.next.call(void 0, );
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.name;
        return;
      }
  }

  _util.unexpected.call(void 0, );
}

function flowParsePostfixType() {
  flowParsePrimaryType();
  while (!_util.canInsertSemicolon.call(void 0, ) && (_index.match.call(void 0, _types.TokenType.bracketL) || _index.match.call(void 0, _types.TokenType.questionDot))) {
    _index.eat.call(void 0, _types.TokenType.questionDot);
    _util.expect.call(void 0, _types.TokenType.bracketL);
    if (_index.eat.call(void 0, _types.TokenType.bracketR)) {
      // Array type
    } else {
      // Indexed access type
      flowParseType();
      _util.expect.call(void 0, _types.TokenType.bracketR);
    }
  }
}

function flowParsePrefixType() {
  if (_index.eat.call(void 0, _types.TokenType.question)) {
    flowParsePrefixType();
  } else {
    flowParsePostfixType();
  }
}

function flowParseAnonFunctionWithoutParens() {
  flowParsePrefixType();
  if (!_base.state.noAnonFunctionType && _index.eat.call(void 0, _types.TokenType.arrow)) {
    flowParseType();
  }
}

function flowParseIntersectionType() {
  _index.eat.call(void 0, _types.TokenType.bitwiseAND);
  flowParseAnonFunctionWithoutParens();
  while (_index.eat.call(void 0, _types.TokenType.bitwiseAND)) {
    flowParseAnonFunctionWithoutParens();
  }
}

function flowParseUnionType() {
  _index.eat.call(void 0, _types.TokenType.bitwiseOR);
  flowParseIntersectionType();
  while (_index.eat.call(void 0, _types.TokenType.bitwiseOR)) {
    flowParseIntersectionType();
  }
}

function flowParseType() {
  flowParseUnionType();
}

 function flowParseTypeAnnotation() {
  flowParseTypeInitialiser();
} exports.flowParseTypeAnnotation = flowParseTypeAnnotation;

function flowParseTypeAnnotatableIdentifier() {
  _expression.parseIdentifier.call(void 0, );
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    flowParseTypeAnnotation();
  }
}

 function flowParseVariance() {
  if (_index.match.call(void 0, _types.TokenType.plus) || _index.match.call(void 0, _types.TokenType.minus)) {
    _index.next.call(void 0, );
    _base.state.tokens[_base.state.tokens.length - 1].isType = true;
  }
} exports.flowParseVariance = flowParseVariance;

// ==================================
// Overrides
// ==================================

 function flowParseFunctionBodyAndFinish(funcContextId) {
  // For arrow functions, `parseArrow` handles the return type itself.
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    flowParseTypeAndPredicateInitialiser();
  }

  _expression.parseFunctionBody.call(void 0, false, funcContextId);
} exports.flowParseFunctionBodyAndFinish = flowParseFunctionBodyAndFinish;

 function flowParseSubscript(
  startTokenIndex,
  noCalls,
  stopState,
) {
  if (_index.match.call(void 0, _types.TokenType.questionDot) && _index.lookaheadType.call(void 0, ) === _types.TokenType.lessThan) {
    if (noCalls) {
      stopState.stop = true;
      return;
    }
    _index.next.call(void 0, );
    flowParseTypeParameterInstantiation();
    _util.expect.call(void 0, _types.TokenType.parenL);
    _expression.parseCallExpressionArguments.call(void 0, );
    return;
  } else if (!noCalls && _index.match.call(void 0, _types.TokenType.lessThan)) {
    const snapshot = _base.state.snapshot();
    flowParseTypeParameterInstantiation();
    _util.expect.call(void 0, _types.TokenType.parenL);
    _expression.parseCallExpressionArguments.call(void 0, );
    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
    } else {
      return;
    }
  }
  _expression.baseParseSubscript.call(void 0, startTokenIndex, noCalls, stopState);
} exports.flowParseSubscript = flowParseSubscript;

 function flowStartParseNewArguments() {
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    const snapshot = _base.state.snapshot();
    flowParseTypeParameterInstantiation();
    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
    }
  }
} exports.flowStartParseNewArguments = flowStartParseNewArguments;

// interfaces
 function flowTryParseStatement() {
  if (_index.match.call(void 0, _types.TokenType.name) && _base.state.contextualKeyword === _keywords.ContextualKeyword._interface) {
    const oldIsType = _index.pushTypeContext.call(void 0, 0);
    _index.next.call(void 0, );
    flowParseInterface();
    _index.popTypeContext.call(void 0, oldIsType);
    return true;fied path is too long.MThe path '{0}' is too long, or a component of the specified path is too long.UThe process cannot access the file '{0}' because it is being used by another process.OThe process cannot access the file because it is being used by another process.Cannot create file mapping.)MemoryMappedViewStreams are fixed length. Stream does not support reading. Stream does not support writing.Cannot access a closed Stream. Cannot access a closed accessor.Named maps are not supported.Access to the path is denied.#Access to the path '{0}' is denied.  Ôªø<linker>
  <assembly fullname="System.IO.MemoryMappedFiles" feature="System.Resources.UseSystemResourceKeys" featurevalue="true">
    <!-- System.Resources.UseSystemResourceKeys removes resource strings and instead uses the resource key as the exception message -->
    <resource name="FxResources.System.IO.MemoryMappedFiles.SR.resources" action="remove" />
    <type fullname="System.SR">
      <method signature="System.Boolean UsingResourceKeys()" body="stub" value="true" />
    </type>
  </assembly>
</linker>    ÃÃÃÃCrossgen2 6.0.2323.48002HÉÏ(ˇûØ  êHÉƒ(√WVHÉÏ(HãÒã˙HãŒˇÑØ  π   ˇaØ  @àxHã~≥  HçHã–ˇqÆ  êHÉƒ(^_√ÃWVHÉÏ(HãÒã˙HãŒˇDØ  HãU≥  @à<HÉƒ(^_√ÃÃÃÃÃÃÃÃÃÃWVHÉÏ(HãÒã˙HãŒˇØ  Hã-≥  @à<HÉƒ(^_√ÃÃÃÃÃÃÃÃÃÃUAWAVAUATWVSHÅÏ»   Hç¨$   HãÒW¿EàEòE®E∏«Eà@   HçMàHâMÄHçç(ˇˇˇˇ√≠  Hãî±  HãMÄˇã¯Hçç(ˇˇˇˇØ≠  Öˇt	HãM∞H;ÒsHÅƒ»   [^_A\A]A^A_]√Hãü≥  Hã	ˇ~∞  HãˇÆ  Hã¯HãœHã÷ˇ^Ø  Hãœˇ-≠  ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃUHÉÏ0Hçl$0Iã¡H¡¯ AÉ·ˇDâL$ LãM0LâL$(Dã»ˇ¥Ø  êHÉƒ0]√ÃÃÃÃÃÃÃÃÃÃÃÃÃUHÉÏ0Hçl$0Iã¡H¡¯ AÉ·ˇDâL$ LãM0LâL$(Dã»ˇ|Ø  êHÉƒ0]√ÃÃÃÃÃÃÃÃÃÃÃÃÃUHÉÏ0Hçl$0Iã¿H¡¯ AÉ‡ˇDâE¸LâL$ Dã¿DãM¸ˇEØ  êHÉƒ0]√ÃÃÃÃÃÃÃÃÃÃÃÃÃÃUHÉÏ Hçl$ ∂“ˇ%Ø  êHÉƒ ]√ÃÃÃÃÃÃUHÉÏ Hçl$ ˇØ  êHÉƒ ]√ÃÃÃÃÃÃÃÃÃHã¡H¡¯ âÉ·ˇAâ√UAWAVAUATWVSHÅÏà   Hç¨$¿   HâM¿Hççhˇˇˇˇ¨  Hã’Ø  HãM¿ˇãHççhˇˇˇˇ´  ã∆HÅƒà   [^_A\A]A^A_]√ÃÃHÉÏ(3“ˇúÆ  êHÉƒ(√ÃÃÃÃÃÃÃÃÃÃÃÃÃÃUWVSHÅÏ¯   Hçl$@3¿HâEW‰H∏pˇˇˇˇˇˇˇ)§∞   )§¿   )§–   HÉ¿0u‚HâÖ∞   Hâe Hã´  HâEãÒHã˙ª 2  HÖˇtª :  W¿EPHçMPÖ$$HÅÏ   HçT$@A∏   ˇ≠  EPÖò   Öò   Ö®   Hçç®   ˇa≠  HâÖê   Hãçê   HâL$ ãç∞   âL$(3…HâL$0ãÀHã◊Dã∆E3…ˇî≠  Ö¿~LHçç®   HçU0Dã»E3¿ˇ≠  E0E HçM ˇw≠  HçP™  Hã	H9Mtˇq™  êHç•∏   [^_]√3¿HâÖê   ˇ¨  É¯zÖÆ   3…Hâçà   Hççà   HâL$ 3…âL$(HâL$0ãÀÅ…   Hã◊Dã∆E3…ˇı¨  Ö¿~3Hãïà   W¿E@HçM@Dã¿ˇf¨  E@E HçM ˇ‘¨  HâEÎHãçà   ˇâ´  Î1HãM Ë®   êHãEHçä©  Hã	H9Mtˇ´©  êHç•∏   [^_]√HçM`∫   A∏   ˇQ´  Hã Æ  HãHçM`ˇM´  LãæÆ  Mã HçM`ã÷ˇÁ´  Hã∞Æ  HãHçM`ˇ#´  HçM`ˇ´  Hç
©  Hã	H9Mtˇ+©  êHç•∏   [^_]√UWVSHÉÏHHãi@Hâl$@Hçm@Hãçà   ˇ¥™  êHÉƒH[^_]√ÃÃHÉÏ83¿HâD$(ãQDã ÎEã»EÖ…~EçAˇD;¬s-HãMc–fBÉ<P v·HçT$(E3¿ˇ0´  HçL$(ˇ=´  êHÉƒ8√ˇë®  ÃÃÃÃÃÃÃÃÃHÉÏ(ˇæ®  ∂@HHÉƒ(√ÃÃÃÃÃÃÃÃÃÃÃÃÃUVHÉÏ8Hçl$@Hâe‡HãÒˇê®  ÄxH t
Hã∆HÉƒ8^]√3¿HâEˇd´  Hã»Hã÷Lç∑ß  9	ˇØß  HâEHãEHÉƒ8^]√UVHÉÏ(Hãi Hâl$ Hçm@Hç€ˇˇˇHÉƒ(^]√ÃÃÃÃÃÃÃWVSHÉÏ HãÒHã˙ˇ®  ÄxH tDπ   ˇ§®  HãÿHçKHã÷ˇƒß  HçKHã◊ˇ∑ß  Hã≠  Hã	Hã”ˇº®  êHÉƒ [^_√HãŒHã◊ˇü®  êHÉƒ [^_√ÃÃÃÃÃÃÃÃÃÃÃÃÃÃWVSHÉÏ ˇ£ß  HãHãHÖ¿u4Hã¨  ˇkß  Hã¯ˇ ß  HãÿHãÀHã◊ˇ©  HãŒHã”ˇ/ß  Hã√HÉƒ [^_√ÃÃÃÃÃÃÃÃÃÃÃÃHÉÏ(Hãm¨  Hã	ˇ™  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(HãU¨  Hã	ˇÙ©  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(Hã=¨  Hã	ˇ‘©  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(Hã%¨  Hã	ˇ¥©  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(Hã¨  Hã	ˇî©  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(Hãı´  Hã	ˇt©  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(Hã›´  Hã	ˇT©  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(Hã≈´  Hã	ˇ4©  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(Hã≠´  Hã	ˇ©  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(Hãï´  Hã	ˇÙ®  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(Hã}´  Hã	ˇ‘®  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(Hãe´  Hã	ˇ¥®  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(HãM´  Hã	ˇî®  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(Hã5´  Hã	ˇt®  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(Hã´  Hã	ˇT®  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(Hã´  Hã	ˇ4®  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(HãÌ™  Hã	ˇ®  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(Hã’™  Hã	ˇÙß  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(HãΩ™  Hã	ˇ‘ß  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(Hã•™  Hã	ˇ¥ß  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(Hãç™  Hã	ˇîß  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(Hãu™  Hã	ˇtß  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(Hã]™  Hã	ˇTß  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(HãE™  Hã	ˇ4ß  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(Hã-™  Hã	ˇß  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(Hã™  Hã	ˇÙ¶  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(Hã˝©  Hã	ˇ‘¶  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(HãÂ©  Hã	ˇ¥¶  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(HãÕ©  Hã	ˇî¶  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(Hãµ©  Hã	ˇt¶  êHÉƒ(√ÃÃÃÃÃÃHÉÏ(Hãù©  Hã	ˇT¶  êHÉƒ(√ÃÃÃÃÃÃVHÉÏ0HãÑ©  Hã	HçT$(ˇ>§  Ñ¿u3ˆÎãD$(@∂ˇ8£  @àpHHÉƒ0^√ÃÃÃÃÃÃVHÉÏ HãÒˇí§  ã»Hã÷ˇ¶  êHÉƒ ^√WVUSHÉÏ(ã˘HãÚÉˇPHç_˛É˚wãÀHçç}  ãàHç‡ˇˇˇH¬ˇ‡Éˇ ÑE  ÉˇPÖÛ  HãŒˇã£  Ñ¿Ö‚  Èî  Åˇ∑   +ÉˇWÑÃ  Åˇ∑   Ö¿  HãŒˇX£  Ñ¿ÖØ  ÈI  ÅˇŒ   Ñâ  Åˇ„  Öí  ˇù¢  HãËHãÕˇô£  ÈÈ  HãŒˇ£  Ñ¿u!Hãxß  Hã	ˇ•  Hã»Hã÷ˇ•  Hã¯ÎHãOß  Hã	ˇÓ§  Hã¯ˇ]¢  HãËHãÕHã◊Lã∆ˇ££  Èã  HãŒˇµ¢  Ñ¿u!HãBß  Hã	ˇ±§  Hã»Hã÷ˇ≠§  HãËÎHã)ß  Hã	ˇê§  HãËˇ¢  HãHãŒHã’ˇP£  HãÓÈ-  HãŒˇW¢  Ñ¿u!Hã¸¶  Hã	ˇS§  Hã»Hã÷ˇO§  HãËÎHã„¶  Hã	ˇ2§  HãËˇë°  HãHãŒHã’ˇí¢  HãÓÈœ  Hãs¶  Hã	ˇ§  Hã»Hã÷ˇ˛£  HãËπ∑   ˇ§  ãˇp°  HãÿHãÀHã’Dã∆ˇŒ¢  HãÎÈÉ  HãŒˇ≠°  Ñ¿u!HãÚ¶  Hã	ˇ©£  Hã»Hã÷ˇ•£  HãËÎHã)¶  Hã	ˇà£  HãËˇ°  HãHãŒHã’ˇx¢  HãÓÈ%  HãŒˇO°  Ñ¿u!HãÃ•  Hã	ˇK£  Hã»Hã÷ˇG£  HãËÎHã≥•  Hã	ˇ*£  HãËπ    ˇ<£  ãˇ§†  Hã¯HãœHã’Dã∆ˇ¢  HãÔÈ∑   Hãc•  Hã	ˇÍ¢  Hã»Hã÷ˇÊ¢  HãËπP   ˇ¢  ãˇX†  Hã¯HãœHã’Dã∆ˇ∂°  HãÔÎnHãŒˇò†  Ñ¿u/ãœ3“ˇj¢  Hã»Hã‡•  HãLãﬁ•  Mã	Lã∆ˇr†  HãËÎãœ3“ˇ;¢  HãËãœˇÄ¢  ãˇËü  Hã¯HãœHã’Dã∆ˇF°  HãÔHã≈HÉƒ([]^_√ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃ˜¡  ˇˇtã¡√ã¡  Ä√ÃÃÃÃÃÃÃÃÃÃÃÃÃHÉÏ(3“ˇÃ°  êHÉƒ(√ÃÃÃÃÃÃÃÃÃÃÃÃÃÃVHãÒHçNˇ û  ∆F^√ÃÃÃÃÃÃÃÃÃÃÃÃWVSHãÒIã¯AãŸHçNˇ¢û  HçNHã◊ˇïû  à^[^_√ÃÃÃÃÃÃHÉÏ(∫   E3¿ˇÆ°  êHÉƒ(√ÃÃÃÃÃÃÃÃHÉÏ(E3¿ˇì°  êHÉƒ(√ÃÃÃÃÃÃÃÃÃÃÃÃÃWVHÉÏ(HÖ…teÉy Ññ   EÖ¿åæ   AÉ¯è¥   âT$H˜¬ˇ˛Ö…   Aã–DãD$HE3…ˇü°  Hãˇ¶û  Hã¯HçOHã÷ˇÊù  ∆GHã«HÉƒ(^_√Hã¡£  Hã	ˇÿ†  Hãˇû  Hã¯Hã%§  HãHãœLã∆ˇÊû  Hãœˇ}ù  HãV£  Hã	ˇù†  Hãˇƒù  Hã¯HãœHã÷ˇùû  HãœˇLù  ˇ∂ù  HãHã‘£  HãHãŒˇòû  HãŒˇ'ù  ˇëù  HãHã∑£  HãHãŒˇsû  HãŒˇù  ÃÃÃÃÃÃÃÃÃÃHÉÏ(3“âT$ ∫   E3¿E3…ˇ=†  êHÉƒ(√ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃHÉÏ(E3¿DâD$ E3…ˇ†  êHÉƒ(√ÃÃÃÃÃHÉÏ(E3…DâL$ ˇˆü  êHÉƒ(√ÃÃÃÃÃÃÃÃHÉÏ(3¿âD$ ˇÿü  êHÉƒ(√ÃÃÃÃÃÃÃÃÃÃUAWAVATWVSHÉÏPHç¨$Ä   Hâe∏HâMã˙IãÿIãÒDãu0HÖ…ÑÚ   HÖ€Ö  HÖˆå@  EÖˆår  AÉ˛èh  ÉˇÑÑ  ÉˇÑ∂  AÉ˛ÑÁ  ˇû  ∂»âMÃAãŒˇgü  Dã¯ˇéú  Lã‡«D$    «D$(   3…âL$0IãÃHãUDã«Eãœˇ ù  IãÃHâM¿HÖˆÑ»  3“âT$ Hât$(Hã”EãŒE3¿ˇ ü  HãÿˇGú  HãHçNHã”ˇáõ  HçNHãU¿ˇyõ  ∆F Hã∆HÉƒP[^_A\A^A_]√ˇ•õ  Hã¯Hã€°  HãHãœˇú  Hãœˇõ  É{ ÖË˛ˇˇHãÌ†  Hã	ˇ4û  Hãˇ[õ  HãÿHãÀHã÷ˇ4ú  HãÀˇ„ö  Hã°  Hã	ˇû  Lãˇ:õ  HãHãp°  HãHãŒMã∆ˇ!ú  HãŒˇ®ö  ˇõ  HãHãP°  HãHãŒˇÙõ  HãŒˇÉö  Hã|†  Hã	ˇ£ù  Hãˇ ö  Hã¯Lã °  Mã HãœHã÷ˇ°õ  HãœˇHö  HãI†  Hã	ˇhù  Hãˇèö  Hã¯LãÂ†  Mã HãœHã÷ˇfõ  Hãœˇö  Hãˆü  Hã	ˇ-ù  HãˇTö  Hã¯Lã¢†  Mã HãœHã÷ˇ+õ  Hãœˇ“ô  Lç{ô  ˇuô  HÖ¿uRHãM¿Lçmô  ˇgô  É}Ã u
HãMˇØõ  HãÄü  Hã	ˇøú  HãÿˇÊô  LãIãŒHã”ˇøö  IãŒˇnô  HãM¿Lçô  ˇô  HãHãM¿È∑˝ˇˇUAWAVATWVSHÉÏ@Hãi8Hâl$8Hç≠Ä   HãM¿ãUÃLãEˇ≤ú  ˇ$ô  ÃÃÃÃAWAVWVUSHÉÏ8HãÒHãÍIã¯AãŸDã¥$ê   HÖˆÑ}  HÖÌÖØ  HÖˇå·  HÖˇÑ∏   Ö€å  É˚è  É˚ÑË   EÖˆå  AÉ˛è  HãŒLç]ò  ˇWò  HÖˇt^3…âL$ Hâ|$(HãŒHã’Eã∆DãÀˇú  Hã¯ˇ<ô  HãÿHçKHã◊ˇ|ò  HçKHã÷ˇoò  ãº$ò   @à{Hã√HÉƒ8[]^_A^A_√HãŒLç⁄ó  ˇ‘ó  Lã¯IãˇÎäHãŒLç¬ó  ˇºó  HÖ¿Ö/ˇˇˇHã‰ù  Hã	ˇ#õ  HãËˇJò  HãHãŒHã’ˇ#ô  HãŒˇ“ó  Hãªù  Hã	ˇÚö  Hã¯ˇò  HãÿLãgû  Mã HãÀHã◊ˇò  HãÀˇóó  ˇò  LãHãû  HãIãŒˇ„ò  IãŒˇró  HãÉù  Hã	ˇíö  Hãˇ¡ó  Hã¯Hãû  HãHãœLã∆ˇ†ò  Hãœˇ7ó  É} ÖG˛ˇˇHãù  Hã	ˇMö  Hãˇtó  Hã¯HãœHã÷ˇMò  Hãœˇ¸ñ  Hã%ù  Hã	ˇö  HãˇSó  Hã¯Hãâù  HãHãœLã∆ˇ:ò  Hãœˇ¡ñ  ˇ+ó  HãHãiù  HãHãŒˇò  HãŒˇúñ  ÃÃÃÃHÉÏ(E3¿DâD$ E3…ˇÎô  êHÉƒ(√ÃÃÃÃÃHÉÏ(E3…DâL$ ˇŒô  êHÉƒ(√ÃÃÃÃÃÃÃÃWVHÉÏ8ãD$pHÖ…t
Éy Ñç   HÖ“éµ   EÖ¿åÁ   AÉ¯è›   DâD$`AÉ¯ÑÛ   A˜¡ˇˇˇ˚Ö!  Ö¿å>  É¯è5  DâL$ HâT$(Hã—Dã¿DãL$`3…ˇyô  Hãˇ†ñ  Hã¯HçOHã÷ˇ‡ï  ∆GHã«HÉƒ8^_√Hããõ  Hã	ˇ“ò  Hãˇ˘ï  Hã¯HãœHã÷ˇ“ñ  HãœˇÅï  Hã¢õ  Hã	ˇ°ò  Hãˇÿï  Hã¯Hãú  HãHãœLã∆ˇøñ  HãœˇFï  ˇ∞ï  HãHãÓõ  HãHãŒˇíñ  HãŒˇ!ï  Hã
õ  Hã	ˇAò  Hãˇhï  Hã¯Lã∂õ  Mã HãœHã÷ˇ?ñ  HãœˇÊî  ˇPï  HãHã¶õ  HãHãŒˇ2ñ  HãŒˇ¡î  ˇ+ï  HãHãIõ  HãHãŒˇñ  HãŒˇúî  ÃÃÃÃHÉÏ(E3¿DâD$ E3…ˇÛó  êHÉƒ(√ÃÃÃÃÃHÉÏ(E3…DâL$ ˇ÷ó  êHÉƒ(√ÃÃÃÃÃÃÃÃWVSHÉÏ0HãÒã|$pHÖˆÑ¶   É~ Ñ◊   HÖ“éˇ   EÖ¿å1  AÉ¯è'  A˜¡ˇˇˇ˚Ö?  Öˇå\  ÉˇèS  AÉ¯u$π   ˇúó  Dã¿ã◊HãŒAπ   ˇòó  HãÿÎHâT$ HãŒã◊ˇkó  Hãÿˇäî  HãHçNHã”ˇ ì  ∆FHã∆HÉƒ0[^_√Hã§ô  Hã	ˇªñ  HãˇÍì  Hã¯Hãö  HãHãœLã∆ˇ…î  Hãœˇ`ì  Hã9ô  Hã	ˇÄñ  Hãˇßì  Hã¯HãœHã÷ˇÄî  Hãœˇ/ì  HãPô  Hã	ˇOñ  HãˇÜì  Hã¯Hãºô  HãH}
  }
} exports.flowParseImportSpecifier = flowParseImportSpecifier;

// parse function type parameters - function foo<T>() {}
 function flowStartParseFunctionParams() {
  // Originally this checked if the method is a getter/setter, but if it was, we'd crash soon
  // anyway, so don't try to propagate that information.
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    const oldIsType = _index.pushTypeContext.call(void 0, 0);
    flowParseTypeParameterDeclaration();
    _index.popTypeContext.call(void 0, oldIsType);
  }
} exports.flowStartParseFunctionParams = flowStartParseFunctionParams;

// parse flow type annotations on variable declarator heads - let foo: string = bar
 function flowAfterParseVarHead() {
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    flowParseTypeAnnotation();
  }
} exports.flowAfterParseVarHead = flowAfterParseVarHead;

// parse the return type of an async arrow function - let foo = (async (): number => {});
 function flowStartParseAsyncArrowFromCallExpression() {
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    const oldNoAnonFunctionType = _base.state.noAnonFunctionType;
    _base.state.noAnonFunctionType = true;
    flowParseTypeAnnotation();
    _base.state.noAnonFunctionType = oldNoAnonFunctionType;
  }
} exports.flowStartParseAsyncArrowFromCallExpression = flowStartParseAsyncArrowFromCallExpression;

// We need to support type parameter declarations for arrow functions. This
// is tricky. There are three situations we need to handle
//
// 1. This is either JSX or an arrow function. We'll try JSX first. If that
//    fails, we'll try an arrow function. If that fails, we'll throw the JSX
//    error.
// 2. This is an arrow function. We'll parse the type parameter declaration,
//    parse the rest, make sure the rest is an arrow function, and go from
//    there
// 3. This is neither. Just call the super method
 function flowParseMaybeAssign(noIn, isWithinParens) {
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    const snapshot = _base.state.snapshot();
    let wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
      _base.state.type = _types.TokenType.typeParameterStart;
    } else {
      return wasArrow;
    }

    const oldIsType = _index.pushTypeContext.call(void 0, 0);
    flowParseTypeParameterDeclaration();
    _index.popTypeContext.call(void 0, oldIsType);
    wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
    if (wasArrow) {
      return true;
    }
    _util.unexpected.call(void 0, );
  }

  return _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
} exports.flowParseMaybeAssign = flowParseMaybeAssign;

// handle return types for arrow functions
 function flowParseArrow() {
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    const oldIsType = _index.pushTypeContext.call(void 0, 0);
    const snapshot = _base.state.snapshot();

    const oldNoAnonFunctionType = _base.state.noAnonFunctionType;
    _base.state.noAnonFunctionType = true;
    flowParseTypeAndPredicateInitialiser();
    _base.state.noAnonFunctionType = oldNoAnonFunctionType;

    if (_util.canInsertSemicolon.call(void 0, )) _util.unexpected.call(void 0, );
    if (!_index.match.call(void 0, _types.TokenType.arrow)) _util.unexpected.call(void 0, );

    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
    }
    _index.popTypeContext.call(void 0, oldIsType);
  }
  return _index.eat.call(void 0, _types.TokenType.arrow);
} exports.flowParseArrow = flowParseArrow;

 function flowParseSubscripts(startTokenIndex, noCalls = false) {
  if (
    _base.state.tokens[_base.state.tokens.length - 1].contextualKeyword === _keywords.ContextualKeyword._async &&
    _index.match.call(void 0, _types.TokenType.lessThan)
  ) {
    const snapshot = _base.state.snapshot();
    const wasArrow = parseAsyncArrowWithTypeParameters();
    if (wasArrow && !_base.state.error) {
      return;
    }
    _base.state.restoreFromSnapshot(snapshot);
  }

  _expression.baseParseSubscripts.call(void 0, startTokenIndex, noCalls);
} exports.flowParseSubscripts = flowParseSubscripts;

// Returns true if there was an arrow function here.
function parseAsyncArrowWithTypeParameters() {
  _base.state.scopeDepth++;
  const startTokenIndex = _base.state.tokens.length;
  _statement.parseFunctionParams.call(void 0, );
  if (!_expression.parseArrow.call(void 0, )) {
    return false;
  }
  _expression.parseArrowExpression.call(void 0, startTokenIndex);
  return true;
}

function flowParseEnumDeclaration() {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._enum);
  _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;
  _expression.parseIdentifier.call(void 0, );
  flowParseEnumBody();
}

function flowParseEnumBody() {
  if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._of)) {
    _index.next.call(void 0, );
  }
  _util.expect.call(void 0, _types.TokenType.braceL);
  flowParseEnumMembers();
  _util.expect.call(void 0, _types.TokenType.braceR);
}

function flowParseEnumMembers() {
  while (!_index.match.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
    if (_index.eat.call(void 0, _types.TokenType.ellipsis)) {
      break;
    }
    flowParseEnumMember();
    if (!_index.match.call(void 0, _types.TokenType.braceR)) {
      _util.expect.call(void 0, _types.TokenType.comma);
    }
  }
}

function flowParseEnumMember() {
  _expression.parseIdentifier.call(void 0, );
  if (_index.eat.call(void 0, _types.TokenType.eq)) {
    // Flow enum values are always just one token (a string, number, or boolean literal).
    _index.next.call(void 0, );
  }
}
